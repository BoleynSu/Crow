{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"getting_started/a_simple_webpage/","text":"Hello World is a good start, but what if you want something a bit more fancy.. Something like an HTML document saying \"Hello World\". If that's what you want, follow along: Basic Webpage \u00b6 Let's start our webpage with.. well.. a webpage. But before we create a webpage we need to place it somewhere Crow recognizes, for now this directory is going to be called templates , but we can change it later . Once our templates folder is created, we can create our HTML document inside it, let's call it fancypage.html . After that we can just place something simple inside it like: templates/fancypage.html <!DOCTYPE html> < html > < body > < p > Hello World! </ p > </ body > </ html > Now that we have our HTML page ready, let's take our Hello World example from earlier: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \"crow.h\" //#include \"crow_all.h\" int main () { crow :: SimpleApp app ; //define your crow application //define your endpoint at the root directory CROW_ROUTE ( app , \"/\" )([](){ return \"Hello world\" ; }); //set the port, set the app to run on multiple threads, and run the app app . port ( 18080 ). multithreaded (). run (); } And now let's modify it so that it returns our cool page: /main.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \"crow.h\" //#include \"crow_all.h\" int main () { crow :: SimpleApp app ; //define your endpoint at the root directory CROW_ROUTE ( app , \"/\" )([](){ auto page = crow :: mustache :: load_text ( \"fancypage.html\" ); return page ; }); app . port ( 18080 ). multithreaded (). run (); } Your project should look something something like: ./ |-templates/ | |-fancypage.html | |-main.cpp |-crow_all.h or ./ |-templates/ | |-fancypage.html | |-crow/ | |-include/... | |-crow.h |-main.cpp Once the code is done compiling, if we call http://localhost:18080/ we get our Hello World in an HTML document rather than just plain text. Note Compilation instructions are available for Linux , MacOS , and Windows Template Webpage with a variable \u00b6 But we can make things even more exciting, we can greet a user by their name instead!! Let's start with our webpage, and modify it with a little bit of mustache syntax: templates/fancypage.html <!DOCTYPE html> < html > < body > < p > Hello {{person}}! </ p > <!--(1)--> </ body > </ html > {{}} in mustache define a simple variable Now let's modify our C++ code to use the variable we just added to our webpage (or template): /main.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \"crow.h\" //#include \"crow_all.h\" int main () { crow :: SimpleApp app ; //define your endpoint at the root directory CROW_ROUTE ( app , \"/<string>\" )([]( std :: string name ){ // (1) auto page = crow :: mustache :: load ( \"fancypage.html\" ); // (2) crow :: mustache :: context ctx ({{ \"person\" , name }}); // (3) return page . render ( ctx ); //(4) }); app . port ( 18080 ). multithreaded (). run (); } We are adding a string variable to the URL and a counterpart ( std::string name ) to our Route, this can be anything the user wants. We are using load() instead of load_text() since we have an actual variable now. We are creating a new context containing the person variable from our template and the name we got from the URL. we are using render(ctx) to apply our context to the template. Now (after compiling the code and running the executable a second time) calling http://localhost:18080/Bob should return a webpage containing \"Hello Bob!\". We did it! For more details on templates and HTML pages in Crow please go here","title":"A simple Webpage"},{"location":"getting_started/a_simple_webpage/#basic-webpage","text":"Let's start our webpage with.. well.. a webpage. But before we create a webpage we need to place it somewhere Crow recognizes, for now this directory is going to be called templates , but we can change it later . Once our templates folder is created, we can create our HTML document inside it, let's call it fancypage.html . After that we can just place something simple inside it like: templates/fancypage.html <!DOCTYPE html> < html > < body > < p > Hello World! </ p > </ body > </ html > Now that we have our HTML page ready, let's take our Hello World example from earlier: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \"crow.h\" //#include \"crow_all.h\" int main () { crow :: SimpleApp app ; //define your crow application //define your endpoint at the root directory CROW_ROUTE ( app , \"/\" )([](){ return \"Hello world\" ; }); //set the port, set the app to run on multiple threads, and run the app app . port ( 18080 ). multithreaded (). run (); } And now let's modify it so that it returns our cool page: /main.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \"crow.h\" //#include \"crow_all.h\" int main () { crow :: SimpleApp app ; //define your endpoint at the root directory CROW_ROUTE ( app , \"/\" )([](){ auto page = crow :: mustache :: load_text ( \"fancypage.html\" ); return page ; }); app . port ( 18080 ). multithreaded (). run (); } Your project should look something something like: ./ |-templates/ | |-fancypage.html | |-main.cpp |-crow_all.h or ./ |-templates/ | |-fancypage.html | |-crow/ | |-include/... | |-crow.h |-main.cpp Once the code is done compiling, if we call http://localhost:18080/ we get our Hello World in an HTML document rather than just plain text. Note Compilation instructions are available for Linux , MacOS , and Windows","title":"Basic Webpage"},{"location":"getting_started/a_simple_webpage/#template-webpage-with-a-variable","text":"But we can make things even more exciting, we can greet a user by their name instead!! Let's start with our webpage, and modify it with a little bit of mustache syntax: templates/fancypage.html <!DOCTYPE html> < html > < body > < p > Hello {{person}}! </ p > <!--(1)--> </ body > </ html > {{}} in mustache define a simple variable Now let's modify our C++ code to use the variable we just added to our webpage (or template): /main.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \"crow.h\" //#include \"crow_all.h\" int main () { crow :: SimpleApp app ; //define your endpoint at the root directory CROW_ROUTE ( app , \"/<string>\" )([]( std :: string name ){ // (1) auto page = crow :: mustache :: load ( \"fancypage.html\" ); // (2) crow :: mustache :: context ctx ({{ \"person\" , name }}); // (3) return page . render ( ctx ); //(4) }); app . port ( 18080 ). multithreaded (). run (); } We are adding a string variable to the URL and a counterpart ( std::string name ) to our Route, this can be anything the user wants. We are using load() instead of load_text() since we have an actual variable now. We are creating a new context containing the person variable from our template and the name we got from the URL. we are using render(ctx) to apply our context to the template. Now (after compiling the code and running the executable a second time) calling http://localhost:18080/Bob should return a webpage containing \"Hello Bob!\". We did it! For more details on templates and HTML pages in Crow please go here","title":"Template Webpage with a variable"},{"location":"getting_started/your_first_application/","text":"This page shows how you can get started with a simple hello world application. 1. Include \u00b6 Starting with an empty main.cpp file, first add #include \"crow.h\" or #include \"crow_all.h\" if you're using the single header file. Note If you are using version v0.3, then you have to put #define CROW_MAIN at the top of one and only one source file. 2. App declaration \u00b6 Next Create a main() and declare a crow :: SimpleApp inside, your code should look like this int main () { crow :: SimpleApp app ; } The App (or SimpleApp) class organizes all the different parts of Crow and provides the developer (you) a simple interface to interact with these parts. For more information, please go here . 3. Adding routes \u00b6 Once you have your app, the next step is to add routes (or endpoints). You can do so with the CROW_ROUTE macro. CROW_ROUTE ( app , \"/\" )([](){ return \"Hello world\" ; }); For more details on routes, please go here . 4. Running the app \u00b6 Once you're happy with how you defined all your routes, you're going to want to instruct Crow to run your app. This is done using the run() method. app . port ( 18080 ). multithreaded (). run (); Please note that the port() and multithreaded() methods aren't needed, Though not using port() will cause the default port ( 80 ) to be used. Putting it all together \u00b6 Once you've followed all the steps above, your code should look similar to this main.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \"crow.h\" //#include \"crow_all.h\" int main () { crow :: SimpleApp app ; //define your crow application //define your endpoint at the root directory CROW_ROUTE ( app , \"/\" )([](){ return \"Hello world\" ; }); //set the port, set the app to run on multiple threads, and run the app app . port ( 18080 ). multithreaded (). run (); } You then need to compile your code on your Linux , MacOS , or Windows machine After building your .cpp file and running the resulting executable, you should be able to access your endpoint at http://localhost:18080 . Opening this URL in your browser will show a white screen with \"Hello world\" typed on it.","title":"Your First Application"},{"location":"getting_started/your_first_application/#1-include","text":"Starting with an empty main.cpp file, first add #include \"crow.h\" or #include \"crow_all.h\" if you're using the single header file. Note If you are using version v0.3, then you have to put #define CROW_MAIN at the top of one and only one source file.","title":"1. Include"},{"location":"getting_started/your_first_application/#2-app-declaration","text":"Next Create a main() and declare a crow :: SimpleApp inside, your code should look like this int main () { crow :: SimpleApp app ; } The App (or SimpleApp) class organizes all the different parts of Crow and provides the developer (you) a simple interface to interact with these parts. For more information, please go here .","title":"2. App declaration"},{"location":"getting_started/your_first_application/#3-adding-routes","text":"Once you have your app, the next step is to add routes (or endpoints). You can do so with the CROW_ROUTE macro. CROW_ROUTE ( app , \"/\" )([](){ return \"Hello world\" ; }); For more details on routes, please go here .","title":"3. Adding routes"},{"location":"getting_started/your_first_application/#4-running-the-app","text":"Once you're happy with how you defined all your routes, you're going to want to instruct Crow to run your app. This is done using the run() method. app . port ( 18080 ). multithreaded (). run (); Please note that the port() and multithreaded() methods aren't needed, Though not using port() will cause the default port ( 80 ) to be used.","title":"4. Running the app"},{"location":"getting_started/your_first_application/#putting-it-all-together","text":"Once you've followed all the steps above, your code should look similar to this main.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \"crow.h\" //#include \"crow_all.h\" int main () { crow :: SimpleApp app ; //define your crow application //define your endpoint at the root directory CROW_ROUTE ( app , \"/\" )([](){ return \"Hello world\" ; }); //set the port, set the app to run on multiple threads, and run the app app . port ( 18080 ). multithreaded (). run (); } You then need to compile your code on your Linux , MacOS , or Windows machine After building your .cpp file and running the resulting executable, you should be able to access your endpoint at http://localhost:18080 . Opening this URL in your browser will show a white screen with \"Hello world\" typed on it.","title":"Putting it all together"},{"location":"getting_started/setup/linux/","text":"Here's how you can install Crow on your favorite GNU/Linux distro. Getting Crow \u00b6 Requirements \u00b6 C++ compiler with at least C++11 support. Asio development headers (1.10.9 or later). (optional) ZLib for HTTP Compression. (optional) OpenSSL for HTTPS support. (optional) CMake for building tests, examples, and/or installing Crow. (optional) Python3 to build tests and/or examples. Note Crow's CI uses g++-9.4 and clang-10.0 running on AMD64 (x86_64) and ARM64v8 architectures. Using a package Manager \u00b6 You can install Crow on GNU/Linux as a pre-made package Debian/Ubuntu Simply download Crow's .deb file from the release section and Install it. Arch Crow is available for Arch based distros through the AUR package crow . Release package \u00b6 Crow provides an archive containing the framework and CMake files, just copy the include folder to /usr/local/include and lib folder to /usr/local/lib . You can also download the crow_all.h file and simply include that into your project. Installing from source \u00b6 Using CMake \u00b6 Download Crow's source code (Either through Github's UI or by using git clone https://github.com/CrowCpp/Crow.git ). Run mkdir build inside of crow's source directory. Navigate to the new \"build\" directory and run the following: cmake .. -DCROW_BUILD_EXAMPLES=OFF -DCROW_BUILD_TESTS=OFF Run make install . Note You can ignore -DCROW_BUILD_EXAMPLES=OFF -DCROW_BUILD_TESTS=OFF if you want to build the Examples and Unit Tests. Note While building you can set the CROW_FEATURES variable (as a ; separated list). You can use an argument such as -DCROW_FEATURES=\"ssl;compression\" . Note You can uninstall Crow at a later time using make uninstall . Manually \u00b6 Crow can be installed manually on your Linux computer. Multiple header files \u00b6 Project Only Copy Crow's include directory to your project's include directory. System wide Copy Crow's include directory to the /usr/local/include directory. Single header (crow_all.h) \u00b6 Warning crow_all.h is recommended only for small, possibly single source file projects, and ideally should not be installed on your system. navigate to the scripts directory and run ./merge_all.py ../include crow_all.h . This will generate a crow_all.h file that you can use in your projects. Note You can also include or exclude middlewares from your crow_all.h by using -i or -e followed by the middleware header file names separated by a comma (e.g. merge_all.py ../include crow_all.h -e cookie_parser to exclude the cookie parser middleware). Compiling your project \u00b6 Using CMake \u00b6 In order to get your CMake project to work with Crow, all you need are the following lines in your CMakeLists.txt: find_package(Crow) target_link_libraries(your_project PUBLIC Crow::Crow) From there CMake should handle compiling and linking your project. Note For optional features like HTTP Compression or HTTPS you can set the CROW_FEATURES variable using lines such as set(CROW_FEATURES \"ssl;compression\") , set(CROW_FEATURES ssl compression) , or set(CROW_FEATURES ssl) . Directly using a compiler \u00b6 All you need to do is run the following command: g++ main.cpp -lpthread You can use arguments like -DCROW_ENABLE_DEBUG , -DCROW_ENABLE_COMPRESSION -lz for HTTP Compression, or -DCROW_ENABLE_SSL -lssl for HTTPS support, or even replace g++ with clang++.","title":"Linux"},{"location":"getting_started/setup/linux/#getting-crow","text":"","title":"Getting Crow"},{"location":"getting_started/setup/linux/#requirements","text":"C++ compiler with at least C++11 support. Asio development headers (1.10.9 or later). (optional) ZLib for HTTP Compression. (optional) OpenSSL for HTTPS support. (optional) CMake for building tests, examples, and/or installing Crow. (optional) Python3 to build tests and/or examples. Note Crow's CI uses g++-9.4 and clang-10.0 running on AMD64 (x86_64) and ARM64v8 architectures.","title":"Requirements"},{"location":"getting_started/setup/linux/#using-a-package-manager","text":"You can install Crow on GNU/Linux as a pre-made package Debian/Ubuntu Simply download Crow's .deb file from the release section and Install it. Arch Crow is available for Arch based distros through the AUR package crow .","title":"Using a package Manager"},{"location":"getting_started/setup/linux/#release-package","text":"Crow provides an archive containing the framework and CMake files, just copy the include folder to /usr/local/include and lib folder to /usr/local/lib . You can also download the crow_all.h file and simply include that into your project.","title":"Release package"},{"location":"getting_started/setup/linux/#installing-from-source","text":"","title":"Installing from source"},{"location":"getting_started/setup/linux/#using-cmake","text":"Download Crow's source code (Either through Github's UI or by using git clone https://github.com/CrowCpp/Crow.git ). Run mkdir build inside of crow's source directory. Navigate to the new \"build\" directory and run the following: cmake .. -DCROW_BUILD_EXAMPLES=OFF -DCROW_BUILD_TESTS=OFF Run make install . Note You can ignore -DCROW_BUILD_EXAMPLES=OFF -DCROW_BUILD_TESTS=OFF if you want to build the Examples and Unit Tests. Note While building you can set the CROW_FEATURES variable (as a ; separated list). You can use an argument such as -DCROW_FEATURES=\"ssl;compression\" . Note You can uninstall Crow at a later time using make uninstall .","title":"Using CMake"},{"location":"getting_started/setup/linux/#manually","text":"Crow can be installed manually on your Linux computer.","title":"Manually"},{"location":"getting_started/setup/linux/#multiple-header-files","text":"Project Only Copy Crow's include directory to your project's include directory. System wide Copy Crow's include directory to the /usr/local/include directory.","title":"Multiple header files"},{"location":"getting_started/setup/linux/#single-header-crow_allh","text":"Warning crow_all.h is recommended only for small, possibly single source file projects, and ideally should not be installed on your system. navigate to the scripts directory and run ./merge_all.py ../include crow_all.h . This will generate a crow_all.h file that you can use in your projects. Note You can also include or exclude middlewares from your crow_all.h by using -i or -e followed by the middleware header file names separated by a comma (e.g. merge_all.py ../include crow_all.h -e cookie_parser to exclude the cookie parser middleware).","title":"Single header (crow_all.h)"},{"location":"getting_started/setup/linux/#compiling-your-project","text":"","title":"Compiling your project"},{"location":"getting_started/setup/linux/#using-cmake_1","text":"In order to get your CMake project to work with Crow, all you need are the following lines in your CMakeLists.txt: find_package(Crow) target_link_libraries(your_project PUBLIC Crow::Crow) From there CMake should handle compiling and linking your project. Note For optional features like HTTP Compression or HTTPS you can set the CROW_FEATURES variable using lines such as set(CROW_FEATURES \"ssl;compression\") , set(CROW_FEATURES ssl compression) , or set(CROW_FEATURES ssl) .","title":"Using CMake"},{"location":"getting_started/setup/linux/#directly-using-a-compiler","text":"All you need to do is run the following command: g++ main.cpp -lpthread You can use arguments like -DCROW_ENABLE_DEBUG , -DCROW_ENABLE_COMPRESSION -lz for HTTP Compression, or -DCROW_ENABLE_SSL -lssl for HTTPS support, or even replace g++ with clang++.","title":"Directly using a compiler"},{"location":"getting_started/setup/macos/","text":"Here's how you can install Crow on your Mac. Getting Crow \u00b6 From a release \u00b6 Archive \u00b6 Crow provides an archive containing the framework and CMake files, You will only need the include folder inside that archive. Single header file \u00b6 You can also download the crow_all.h file which replaces the include folder. From Source \u00b6 To get Crow from source, you only need to download the repository (as a .zip or through git clone https://github.com/CrowCpp/Crow.git ). include folder \u00b6 Once you've downloaded Crow's source code, you only need to take the include folder. Single header file \u00b6 You can generate your own single header file by navigating to the scripts folder with your terminal and running the following command: python3 merge_all.py ../include crow_all.h This will generate a crow_all.h file which you can use in the following steps Warning crow_all.h is recommended only for small, possibly single source file projects. For larger projects, it is advised to use the multi-header version. Setting up your Crow project \u00b6 Using XCode \u00b6 Download and install Homebrew . Run brew install asio in your terminal. Create a new XCode project (macOS -> Command Line Tool). Change the following project settings: Multiple Headers Add header search paths for crow's include folder and asio's folder ( /usr/local/include , /usr/local/Cellar/asio/include , and where you placed Crow's include folder) Add linker flags ( -lpthread ) Single Header Place crow_all.h inside your project folder and add it to the project in XCode (you need to use File -> Add files to \"project_name\") Add header search paths for asio's folder ( /usr/local/include , and /usr/local/Cellar/asio/include ) Add linker flags ( -lpthread ) Write your Crow application in main.cpp (something like the Hello World example will work). Press \u25b6 to compile and run your Crow application. Building Crow's tests/examples \u00b6 Note This tutorial can be used for Crow projects built with CMake as well Download and install Homebrew . Run brew install cmake asio in your terminal. Get Crow's source code (the entire source code). Run the following Commands: mkdir build cd build cmake .. make -j12 Note You can add options like -DCROW_FEATURES=\"ssl;compression\" or -DCROW_AMALGAMATE to cmake .. to build optional tests/examples for HTTP Compression or HTTPS. Compiling using a compiler directly \u00b6 All you need to do is run the following command: g++ main.cpp -lpthread Note You'll need to install GCC via brew install gcc . the Clang compiler should be part of XCode or XCode command line tools. You can use arguments like -DCROW_ENABLE_DEBUG , -DCROW_ENABLE_COMPRESSION -lz for HTTP Compression, or -DCROW_ENABLE_SSL -lssl for HTTPS support, or even replace g++ with clang++.","title":"MacOS"},{"location":"getting_started/setup/macos/#getting-crow","text":"","title":"Getting Crow"},{"location":"getting_started/setup/macos/#from-a-release","text":"","title":"From a release"},{"location":"getting_started/setup/macos/#archive","text":"Crow provides an archive containing the framework and CMake files, You will only need the include folder inside that archive.","title":"Archive"},{"location":"getting_started/setup/macos/#single-header-file","text":"You can also download the crow_all.h file which replaces the include folder.","title":"Single header file"},{"location":"getting_started/setup/macos/#from-source","text":"To get Crow from source, you only need to download the repository (as a .zip or through git clone https://github.com/CrowCpp/Crow.git ).","title":"From Source"},{"location":"getting_started/setup/macos/#include-folder","text":"Once you've downloaded Crow's source code, you only need to take the include folder.","title":"include folder"},{"location":"getting_started/setup/macos/#single-header-file_1","text":"You can generate your own single header file by navigating to the scripts folder with your terminal and running the following command: python3 merge_all.py ../include crow_all.h This will generate a crow_all.h file which you can use in the following steps Warning crow_all.h is recommended only for small, possibly single source file projects. For larger projects, it is advised to use the multi-header version.","title":"Single header file"},{"location":"getting_started/setup/macos/#setting-up-your-crow-project","text":"","title":"Setting up your Crow project"},{"location":"getting_started/setup/macos/#using-xcode","text":"Download and install Homebrew . Run brew install asio in your terminal. Create a new XCode project (macOS -> Command Line Tool). Change the following project settings: Multiple Headers Add header search paths for crow's include folder and asio's folder ( /usr/local/include , /usr/local/Cellar/asio/include , and where you placed Crow's include folder) Add linker flags ( -lpthread ) Single Header Place crow_all.h inside your project folder and add it to the project in XCode (you need to use File -> Add files to \"project_name\") Add header search paths for asio's folder ( /usr/local/include , and /usr/local/Cellar/asio/include ) Add linker flags ( -lpthread ) Write your Crow application in main.cpp (something like the Hello World example will work). Press \u25b6 to compile and run your Crow application.","title":"Using XCode"},{"location":"getting_started/setup/macos/#building-crows-testsexamples","text":"Note This tutorial can be used for Crow projects built with CMake as well Download and install Homebrew . Run brew install cmake asio in your terminal. Get Crow's source code (the entire source code). Run the following Commands: mkdir build cd build cmake .. make -j12 Note You can add options like -DCROW_FEATURES=\"ssl;compression\" or -DCROW_AMALGAMATE to cmake .. to build optional tests/examples for HTTP Compression or HTTPS.","title":"Building Crow's tests/examples"},{"location":"getting_started/setup/macos/#compiling-using-a-compiler-directly","text":"All you need to do is run the following command: g++ main.cpp -lpthread Note You'll need to install GCC via brew install gcc . the Clang compiler should be part of XCode or XCode command line tools. You can use arguments like -DCROW_ENABLE_DEBUG , -DCROW_ENABLE_COMPRESSION -lz for HTTP Compression, or -DCROW_ENABLE_SSL -lssl for HTTPS support, or even replace g++ with clang++.","title":"Compiling using a compiler directly"},{"location":"getting_started/setup/windows/","text":"Here's how you can install Crow on your Windows machine. Getting and Compiling Crow \u00b6 Using A package manager \u00b6 VCPKG \u00b6 Crow can be simply installed through VCPKG using the command vcpkg install crow Manually (source or release) \u00b6 Microsoft Visual Studio and VCPKG \u00b6 The following guide will use example_with_all.cpp as the Crow application for demonstration purposes. VCPKG will be used only to install Crow's dependencies. Generate crow_all.h by navigating to the scripts folder and running python3 merge_all.py ..\\include crow_all.h . git clone https://github.com/microsoft/vcpkg.git .\\vcpkg\\bootstrap-vcpkg.bat .\\vcpkg\\vcpkg integrate install Create empty Visual Studio project. In solution explorer, right click the name of your project then click Open Folder in File Explorer . Copy crow_all.h , example_with_all.cpp , vcpkg.json to opened folder. Add crow_all.h to Header Files and example_with_all.cpp to Source Files . In solution explorer, right click the name of your project then click Properties . Under vcpkg , set Use Vcpkg Manifest to Yes and Additional Options to --feature-flags=\"versions\" . Set Debug/Release and x64/x86 . Run.","title":"Windows"},{"location":"getting_started/setup/windows/#getting-and-compiling-crow","text":"","title":"Getting and Compiling Crow"},{"location":"getting_started/setup/windows/#using-a-package-manager","text":"","title":"Using A package manager"},{"location":"getting_started/setup/windows/#vcpkg","text":"Crow can be simply installed through VCPKG using the command vcpkg install crow","title":"VCPKG"},{"location":"getting_started/setup/windows/#manually-source-or-release","text":"","title":"Manually (source or release)"},{"location":"getting_started/setup/windows/#microsoft-visual-studio-and-vcpkg","text":"The following guide will use example_with_all.cpp as the Crow application for demonstration purposes. VCPKG will be used only to install Crow's dependencies. Generate crow_all.h by navigating to the scripts folder and running python3 merge_all.py ..\\include crow_all.h . git clone https://github.com/microsoft/vcpkg.git .\\vcpkg\\bootstrap-vcpkg.bat .\\vcpkg\\vcpkg integrate install Create empty Visual Studio project. In solution explorer, right click the name of your project then click Open Folder in File Explorer . Copy crow_all.h , example_with_all.cpp , vcpkg.json to opened folder. Add crow_all.h to Header Files and example_with_all.cpp to Source Files . In solution explorer, right click the name of your project then click Properties . Under vcpkg , set Use Vcpkg Manifest to Yes and Additional Options to --feature-flags=\"versions\" . Set Debug/Release and x64/x86 . Run.","title":"Microsoft Visual Studio and VCPKG"},{"location":"guides/app/","text":"A Crow app defines an interface to allow the developer access to all the different parts of the framework, without having to manually deal with each one. An app allows access to the HTTP server (for handling connections), router (for handling URLs and requests), Middlewares (for extending Crow), among many others. Crow has 2 different app types: SimpleApp \u00b6 Has no middlewares. App<m1, m2, ...> \u00b6 Has middlewares. Using the app \u00b6 To use a Crow app, simply define crow :: SimpleApp or crow :: App < m1 , m2 ... > if you're using middlewares. The methods of an app can be chained. That means that you can configure and run your app in the same code line. app . bindaddr ( 192.168.1.2 ). port ( 443 ). ssl_file ( \"certfile.crt\" , \"keyfile.key\" ). multithreaded (). run (); Or if you like your code neat app . bindaddr ( 192.168.1.2 ) . port ( 443 ) . ssl_file ( \"certfile.crt\" , \"keyfile.key\" ) . multithreaded () . run (); Note The run() method is blocking. To run a Crow app asynchronously run_async() should be used instead. Warning When using run_async() , make sure to use a variable to save the function's output (such as auto _a = app . run_async () ). Otherwise the app will run synchronously. For more info on middlewares, check out this page . For more info on what functions are available to a Crow app, go here .","title":"App"},{"location":"guides/app/#simpleapp","text":"Has no middlewares.","title":"SimpleApp"},{"location":"guides/app/#appm1-m2","text":"Has middlewares.","title":"App&lt;m1, m2, ...&gt;"},{"location":"guides/app/#using-the-app","text":"To use a Crow app, simply define crow :: SimpleApp or crow :: App < m1 , m2 ... > if you're using middlewares. The methods of an app can be chained. That means that you can configure and run your app in the same code line. app . bindaddr ( 192.168.1.2 ). port ( 443 ). ssl_file ( \"certfile.crt\" , \"keyfile.key\" ). multithreaded (). run (); Or if you like your code neat app . bindaddr ( 192.168.1.2 ) . port ( 443 ) . ssl_file ( \"certfile.crt\" , \"keyfile.key\" ) . multithreaded () . run (); Note The run() method is blocking. To run a Crow app asynchronously run_async() should be used instead. Warning When using run_async() , make sure to use a variable to save the function's output (such as auto _a = app . run_async () ). Otherwise the app will run synchronously. For more info on middlewares, check out this page . For more info on what functions are available to a Crow app, go here .","title":"Using the app"},{"location":"guides/auth/","text":"While Crow doesn't directly support HTTP authentication, it does provide all the tools you need to build your own. This tutorial will show you how to setup basic and token authentication using Crow. Shared information \u00b6 Every way boils down to the same basic flow: - The handler calls a verification function. - The handler provides a request and \\<optionally> a response . - The function returns a bool or enum status. - Handler either continues or stops executing based on the returned status. - Either the function or handler modify and end() the response in case of failure. For the purposes of this tutorial, we will assume that the verification function is defined as bool verify ( crow :: request req , crow :: response res ) Basic Auth \u00b6 Basic HTTP authentication requires the client to send the Username and Password as a single string, separated by a colon (':') and then encoded as Base64. This data needs to be placed in the Authorization header of the request. A sample header using the credentials \"Username\" and \"Password\" would look like this: Authorization: Basic VXNlcm5hbWU6UGFzc3dvcmQ= . We don't need to worry about creating the request, we only need to extract the credentials from the Authorization header and verify them. Note There are multiple ways to verify the credentials. Most involve checking the username in a database, then checking a hash of the password against the stored password hash for that username. This tutorial will not go over them To do this we first need to get the Authorization header as a string by using the following code: std :: string myauth = req . get_header_value ( \"Authorization\" ); Next we need to isolate our encoded credentials and decode them as follows: std :: string mycreds = myauth . substr ( 6 ); std :: string d_mycreds = crow :: utility :: base64decode ( mycreds , mycreds . size ()); Now that we have our username:password string, we only need to separate it into 2 different strings and verify their validity: size_t found = d_mycreds . find ( ':' ); std :: string username = d_mycreds . substr ( 0 , found ); std :: string password = d_mycreds . substr ( found + 1 ); /*Verify validity of username and password here*/ return true ; //or false if the username/password are invalid Token Auth \u00b6 Tokens are some form of unique data that a server can provide to a client in order to verify the client's identity later. While on the surface level they don't provide more security than a strong password, they are designed to be less valuable by being temporary and providing limited access . Variables like expiration time and access scopes are heavily reliant on the implementation however. Access Tokens \u00b6 The kind of the token itself can vary depending on the implementation and project requirements: Many services use randomly generated strings as tokens. Then compare them against a database to retrieve the associated user data. Some services however prefer using data bearing tokens. One example of the latter kind is JWT, which uses JSON strings encoded in Base64 and signed using a private key or an agreed upon secret. While this has the added hassle of signing the token to ensure that it's not been tampered with. It does allow for the client to issue tokens without ever needing to present a password or contact a server. The server would simply be able to verify the signature using the client's public key or secret. Using an Access Token \u00b6 Authenticating with an access token usually involves 2 stages: The first being acquiring the access token from an authority (either by providing credentials such as a username and a password to a server or generating a signed token). The scope of the token (what kind of information it can read or change) is usually defined in this step. The second stage is simply presenting the Token to the server when requesting a resource. This is even simpler than using basic authentication. All the client needs to do is provide the Authorization header with a keyword (usually Bearer ) followed by the token itself (for example: Authorization: Bearer ABC123 ). Once the client has done that the server will need to acquire this token, which can easily be done as follows: std :: string myauth = req . get_header_value ( \"Authorization\" ); std :: string mycreds = myauth . substr ( 7 ); // The length can change based on the keyword used /*Verify validity of the token here*/ return true ; //or false if the token is invalid The way of verifying the token is largely up to the implementation, and involves either Bearer token decoding and verification, or database access, neither of which is in this tutorial's scope. Refresh Tokens \u00b6 Some services may choose to provide a refresh token alongside the access token. This token can be used to request a new access token if the existing one has expired. It provides convenience and security in that it makes it possible to acquire new access tokens without the need to expose a password. The downside however is that it can allow a malicious entity to keep its access to a compromised account. As such refresh tokens need to be handled with care, kept secure, and always invalidated as soon as a client logs out or requests a new access token. Sessions \u00b6 While Crow does not provide built in support for user sessions, a community member was kind enough to provide their own implementation on one of the related issue, their comment along with the code is available here (Please keep in mind that while we appreciate all efforts to push Crow forward, we cannot provide support for this implementation unless it becomes part of the core project).","title":"HTTP Authorization"},{"location":"guides/auth/#shared-information","text":"Every way boils down to the same basic flow: - The handler calls a verification function. - The handler provides a request and \\<optionally> a response . - The function returns a bool or enum status. - Handler either continues or stops executing based on the returned status. - Either the function or handler modify and end() the response in case of failure. For the purposes of this tutorial, we will assume that the verification function is defined as bool verify ( crow :: request req , crow :: response res )","title":"Shared information"},{"location":"guides/auth/#basic-auth","text":"Basic HTTP authentication requires the client to send the Username and Password as a single string, separated by a colon (':') and then encoded as Base64. This data needs to be placed in the Authorization header of the request. A sample header using the credentials \"Username\" and \"Password\" would look like this: Authorization: Basic VXNlcm5hbWU6UGFzc3dvcmQ= . We don't need to worry about creating the request, we only need to extract the credentials from the Authorization header and verify them. Note There are multiple ways to verify the credentials. Most involve checking the username in a database, then checking a hash of the password against the stored password hash for that username. This tutorial will not go over them To do this we first need to get the Authorization header as a string by using the following code: std :: string myauth = req . get_header_value ( \"Authorization\" ); Next we need to isolate our encoded credentials and decode them as follows: std :: string mycreds = myauth . substr ( 6 ); std :: string d_mycreds = crow :: utility :: base64decode ( mycreds , mycreds . size ()); Now that we have our username:password string, we only need to separate it into 2 different strings and verify their validity: size_t found = d_mycreds . find ( ':' ); std :: string username = d_mycreds . substr ( 0 , found ); std :: string password = d_mycreds . substr ( found + 1 ); /*Verify validity of username and password here*/ return true ; //or false if the username/password are invalid","title":"Basic Auth"},{"location":"guides/auth/#token-auth","text":"Tokens are some form of unique data that a server can provide to a client in order to verify the client's identity later. While on the surface level they don't provide more security than a strong password, they are designed to be less valuable by being temporary and providing limited access . Variables like expiration time and access scopes are heavily reliant on the implementation however.","title":"Token Auth"},{"location":"guides/auth/#access-tokens","text":"The kind of the token itself can vary depending on the implementation and project requirements: Many services use randomly generated strings as tokens. Then compare them against a database to retrieve the associated user data. Some services however prefer using data bearing tokens. One example of the latter kind is JWT, which uses JSON strings encoded in Base64 and signed using a private key or an agreed upon secret. While this has the added hassle of signing the token to ensure that it's not been tampered with. It does allow for the client to issue tokens without ever needing to present a password or contact a server. The server would simply be able to verify the signature using the client's public key or secret.","title":"Access Tokens"},{"location":"guides/auth/#using-an-access-token","text":"Authenticating with an access token usually involves 2 stages: The first being acquiring the access token from an authority (either by providing credentials such as a username and a password to a server or generating a signed token). The scope of the token (what kind of information it can read or change) is usually defined in this step. The second stage is simply presenting the Token to the server when requesting a resource. This is even simpler than using basic authentication. All the client needs to do is provide the Authorization header with a keyword (usually Bearer ) followed by the token itself (for example: Authorization: Bearer ABC123 ). Once the client has done that the server will need to acquire this token, which can easily be done as follows: std :: string myauth = req . get_header_value ( \"Authorization\" ); std :: string mycreds = myauth . substr ( 7 ); // The length can change based on the keyword used /*Verify validity of the token here*/ return true ; //or false if the token is invalid The way of verifying the token is largely up to the implementation, and involves either Bearer token decoding and verification, or database access, neither of which is in this tutorial's scope.","title":"Using an Access Token"},{"location":"guides/auth/#refresh-tokens","text":"Some services may choose to provide a refresh token alongside the access token. This token can be used to request a new access token if the existing one has expired. It provides convenience and security in that it makes it possible to acquire new access tokens without the need to expose a password. The downside however is that it can allow a malicious entity to keep its access to a compromised account. As such refresh tokens need to be handled with care, kept secure, and always invalidated as soon as a client logs out or requests a new access token.","title":"Refresh Tokens"},{"location":"guides/auth/#sessions","text":"While Crow does not provide built in support for user sessions, a community member was kind enough to provide their own implementation on one of the related issue, their comment along with the code is available here (Please keep in mind that while we appreciate all efforts to push Crow forward, we cannot provide support for this implementation unless it becomes part of the core project).","title":"Sessions"},{"location":"guides/base64/","text":"Encoding \u00b6 Using crow :: utility :: base64encode ( mystring , mystring . size ()) will return a Base64 encoded string. For URL safe Base64 crow :: utility :: base64encode_urlsafe ( mystring , mystring . size ()) can be used. The key used in the encoding process can be changed, it is a string containing all 64 characters to be used. Decoding \u00b6 v1.0 Using crow :: utility :: base64decode ( mystring , mystring . size ()) with mystring being a Base64 encoded string will return a plain-text string. The function works with both normal and URL safe Base64. However it cannot decode a Base64 string encoded with a custom key.","title":"Base64"},{"location":"guides/base64/#encoding","text":"Using crow :: utility :: base64encode ( mystring , mystring . size ()) will return a Base64 encoded string. For URL safe Base64 crow :: utility :: base64encode_urlsafe ( mystring , mystring . size ()) can be used. The key used in the encoding process can be changed, it is a string containing all 64 characters to be used.","title":"Encoding"},{"location":"guides/base64/#decoding","text":"v1.0 Using crow :: utility :: base64decode ( mystring , mystring . size ()) with mystring being a Base64 encoded string will return a plain-text string. The function works with both normal and URL safe Base64. However it cannot decode a Base64 string encoded with a custom key.","title":"Decoding"},{"location":"guides/blueprints/","text":"v1.0 Crow supports flask style blueprints. A blueprint is a limited app. It cannot handle networking. But it can handle routes. Blueprints allow developers to compartmentalize their Crow applications, making them a lot more modular. In order for a blueprint to work, it has to be registered with a Crow app before the app is run. This can be done using app . register_blueprint ( blueprint ); . Blueprints let you do the following: Define Routes \u00b6 You can define routes in a blueprint, similarly to how CROW_ROUTE ( app , \"/xyz\" ) works, you can use CROW_BP_ROUTE ( blueprint , \"/xyz\" ) to define a blueprint route. Define a Prefix \u00b6 Blueprints can have a prefix assigned to them. This can be done when creating a new blueprint as in crow :: blueprint bp ( \"prefix\" ); . This prefix will be applied to all routes belonging to the blueprint, turning a route such as /crow/rocks into /prefix/crow/rocks . Warning Unlike routes, blueprint prefixes should contain no slashes. Use a custom Static directory \u00b6 Blueprints let you define a custom static directory (relative to your working directory). This can be done by initializing a blueprint as crow :: blueprint bp ( \"prefix\" , \"custom_static\" ); . This does not have an effect on set_static_file_info () , it's only for when you want direct access to a file. Note Currently changing which endpoint the blueprint uses isn't possible, so whatever you've set in CROW_STATIC_ENDPOINT (default is \"static\") will be used. Making your final route /prefix/static/filename . Use a custom Templates directory \u00b6 Similar to static directories, You can set a custom templates directory (relative to your working directory). To do this you initialize the blueprint as crow :: blueprint bp ( \"prefix\" , \"custom_static\" , \"custom_templates\" ); . Any routes defined for the blueprint will use that directory when calling crow :: mustache :: load ( \"filename.html\" ) . Note If you want to define a custom templates directory without defining a custom static directory, you can pass the static directory as an empty string. Making your constructor crow :: blueprint bp ( \"prefix\" , \"\" , \"custom_templates\" ); . Define a custom Catchall route \u00b6 You can define a custom catchall route for a blueprint by calling CROW_BP_CATCHALL_ROUTE ( blueprint ) . This causes any requests with a URL starting with /prefix and no route found to call the blueprint's catchall route. If no catchall route is defined, Crow will default to either the parent blueprint or the app's catchall route. Register other Blueprints \u00b6 Blueprints can also register other blueprints. This is done through blueprint . register_blueprint ( blueprint_2 ); . The child blueprint's routes become /prefix/prefix_2/abc/xyz .","title":"Blueprints"},{"location":"guides/blueprints/#define-routes","text":"You can define routes in a blueprint, similarly to how CROW_ROUTE ( app , \"/xyz\" ) works, you can use CROW_BP_ROUTE ( blueprint , \"/xyz\" ) to define a blueprint route.","title":"Define Routes"},{"location":"guides/blueprints/#define-a-prefix","text":"Blueprints can have a prefix assigned to them. This can be done when creating a new blueprint as in crow :: blueprint bp ( \"prefix\" ); . This prefix will be applied to all routes belonging to the blueprint, turning a route such as /crow/rocks into /prefix/crow/rocks . Warning Unlike routes, blueprint prefixes should contain no slashes.","title":"Define a Prefix"},{"location":"guides/blueprints/#use-a-custom-static-directory","text":"Blueprints let you define a custom static directory (relative to your working directory). This can be done by initializing a blueprint as crow :: blueprint bp ( \"prefix\" , \"custom_static\" ); . This does not have an effect on set_static_file_info () , it's only for when you want direct access to a file. Note Currently changing which endpoint the blueprint uses isn't possible, so whatever you've set in CROW_STATIC_ENDPOINT (default is \"static\") will be used. Making your final route /prefix/static/filename .","title":"Use a custom Static directory"},{"location":"guides/blueprints/#use-a-custom-templates-directory","text":"Similar to static directories, You can set a custom templates directory (relative to your working directory). To do this you initialize the blueprint as crow :: blueprint bp ( \"prefix\" , \"custom_static\" , \"custom_templates\" ); . Any routes defined for the blueprint will use that directory when calling crow :: mustache :: load ( \"filename.html\" ) . Note If you want to define a custom templates directory without defining a custom static directory, you can pass the static directory as an empty string. Making your constructor crow :: blueprint bp ( \"prefix\" , \"\" , \"custom_templates\" ); .","title":"Use a custom Templates directory"},{"location":"guides/blueprints/#define-a-custom-catchall-route","text":"You can define a custom catchall route for a blueprint by calling CROW_BP_CATCHALL_ROUTE ( blueprint ) . This causes any requests with a URL starting with /prefix and no route found to call the blueprint's catchall route. If no catchall route is defined, Crow will default to either the parent blueprint or the app's catchall route.","title":"Define a custom Catchall route"},{"location":"guides/blueprints/#register-other-blueprints","text":"Blueprints can also register other blueprints. This is done through blueprint . register_blueprint ( blueprint_2 ); . The child blueprint's routes become /prefix/prefix_2/abc/xyz .","title":"Register other Blueprints"},{"location":"guides/compression/","text":"v0.3 Crow supports Zlib compression using Gzip or Deflate algorithms. HTTP Compression \u00b6 HTTP compression is by default disabled in crow. Do the following to enable it: - Define CROW_ENABLE_COMPRESSION in your compiler definitions ( g++ main.cpp -DCROW_ENABLE_COMPRESSION for example) or set(CROW_FEATURES compression) in CMakeLists.txt . - Call use_compression ( crow :: compression :: algorithm ) on your Crow app. - When compiling your application, make sure that ZLIB is included as a dependency. Either through -lz compiler argument or find_package(ZLIB) in CMake. Note 3 rd point is not needed for MSVC or CMake projects using Crow::Crow since vcpkg.json and Crow's target already include zlib as a dependency. For the compression algorithm you can use crow::compression::algorithm::DEFLATE or crow::compression::algorithm::GZIP . And now your HTTP responses will be compressed. Websocket Compression \u00b6 Crow currently does not support Websocket compression. Feel free to discuss the subject with us on GitHub if you're feeling adventurous and want to try to implement it. We appreciate all the help.","title":"Compression"},{"location":"guides/compression/#http-compression","text":"HTTP compression is by default disabled in crow. Do the following to enable it: - Define CROW_ENABLE_COMPRESSION in your compiler definitions ( g++ main.cpp -DCROW_ENABLE_COMPRESSION for example) or set(CROW_FEATURES compression) in CMakeLists.txt . - Call use_compression ( crow :: compression :: algorithm ) on your Crow app. - When compiling your application, make sure that ZLIB is included as a dependency. Either through -lz compiler argument or find_package(ZLIB) in CMake. Note 3 rd point is not needed for MSVC or CMake projects using Crow::Crow since vcpkg.json and Crow's target already include zlib as a dependency. For the compression algorithm you can use crow::compression::algorithm::DEFLATE or crow::compression::algorithm::GZIP . And now your HTTP responses will be compressed.","title":"HTTP Compression"},{"location":"guides/compression/#websocket-compression","text":"Crow currently does not support Websocket compression. Feel free to discuss the subject with us on GitHub if you're feeling adventurous and want to try to implement it. We appreciate all the help.","title":"Websocket Compression"},{"location":"guides/included-middleware/","text":"Crow contains some middlewares that are ready to be used in your application. Make sure you understand how to enable and use middleware . Sessions \u00b6 Include: crow/middlewares/session.h Examples: examples/middlewares/session.cpp This middleware can be used for managing sessions - small packets of data associated with a single client that persist across multiple requests. Sessions shouldn't store anything permanent, but only context that is required to easily work with the current client (is the user authenticated, what page did he visit last, etc.). Setup \u00b6 Session data can be stored in multiple ways: crow::InMemoryStore - stores all data in memory crow::FileStore - stores all all data in json files A custom store Always list the CookieParser before the Session using Session = crow :: SessionMiddleware < crow :: FileStore > ; crow :: App < crow :: CookieParser , Session > app { Session { crow :: FileStore { \"/tmp/sessiondata\" } }}; Session ids are represented as random alphanumeric strings and are stored in cookies. See the examples for more customization options. Usage \u00b6 A session is basically a key-value map with support for multiple types: strings, integers, booleans and doubles. The map is created and persisted automatically as soon it is first written to. auto & session = app . get_context < Session > ( request ); session . get ( \"key\" , \"not-found\" ); // get string by key and return \"not-found\" if not found session . get ( \"int\" , -1 ); session . get < bool > ( \"flag\" ); // returns default value(false) if not found session . set ( \"key\" , \"new value\" ); session . string ( \"any-type\" ); // return any type as string representation session . remove ( \"key\" ); session . keys (); // return list of keys Session objects are shared between concurrent requests, this means we can perform atomic operations and even lock the object. session . apply ( \"views\" , []( int v ){ return v + 1 ;}); // this operation is always atomic, no way to get a data race session . mutex (). lock (); // manually lock session Expiration \u00b6 Expiration can happen either by the cookie expiring or the store deleting \"old\" data. By default, cookies expire after 30 days. This can be changed with the cookie option in the Session constructor. crow::FileStore automatically supports deleting files that are expired (older than 30 days). The expiration age can also be changed in the constructor. The session expiration can be postponed. This will make the Session issue a new cookie and make the store acknowledge the new expiration time. session . refresh_expiration () Cookies \u00b6 Include: crow/middlewares/cookie_parser.h Examples: examples/middlewares/example_cookies.cpp This middleware allows to read and write cookies by using CookieParser . Once enabled, it parses all incoming cookies. Cookies can be read and written with the middleware context. All cookie attributes can be changed as well. auto & ctx = app . get_context < crow :: CookieParser > ( request ); std :: string value = ctx . get_cookie ( \"key\" ); ctx . set_cookie ( \"key\" , \"value\" ) . path ( \"/\" ) . max_age ( 120 ); Note Make sure CookieParser is listed before any other middleware that relies on it. CORS \u00b6 Include: crow/middlewares/cors.h Examples: examples/middlewares/example_cors.cpp This middleware allows to set CORS policies by using CORSHandler . Once enabled, it will apply the default CORS rules globally. The CORS rules can be modified by first getting the middleware via auto & cors = app . get_middleware < crow :: CORSHandler > (); . The rules can be set per URL prefix using prefix() , per blueprint using blueprint() , or globally via global() . These will return a CORSRules object which contains the actual rules for the prefix, blueprint, or application. For more details go here . CORSRules can be modified using the methods origin() , methods() , headers() , max_age() , allow_credentials() , or ignore() . For more details on these methods and what default values they take go here . auto & cors = app . get_middleware < crow :: CORSHandler > (); cors . global () . headers ( \"X-Custom-Header\" , \"Upgrade-Insecure-Requests\" ) . methods ( \"POST\" _method , \"GET\" _method ) . prefix ( \"/cors\" ) . origin ( \"example.com\" );","title":"Included Middlewares"},{"location":"guides/included-middleware/#sessions","text":"Include: crow/middlewares/session.h Examples: examples/middlewares/session.cpp This middleware can be used for managing sessions - small packets of data associated with a single client that persist across multiple requests. Sessions shouldn't store anything permanent, but only context that is required to easily work with the current client (is the user authenticated, what page did he visit last, etc.).","title":"Sessions"},{"location":"guides/included-middleware/#setup","text":"Session data can be stored in multiple ways: crow::InMemoryStore - stores all data in memory crow::FileStore - stores all all data in json files A custom store Always list the CookieParser before the Session using Session = crow :: SessionMiddleware < crow :: FileStore > ; crow :: App < crow :: CookieParser , Session > app { Session { crow :: FileStore { \"/tmp/sessiondata\" } }}; Session ids are represented as random alphanumeric strings and are stored in cookies. See the examples for more customization options.","title":"Setup"},{"location":"guides/included-middleware/#usage","text":"A session is basically a key-value map with support for multiple types: strings, integers, booleans and doubles. The map is created and persisted automatically as soon it is first written to. auto & session = app . get_context < Session > ( request ); session . get ( \"key\" , \"not-found\" ); // get string by key and return \"not-found\" if not found session . get ( \"int\" , -1 ); session . get < bool > ( \"flag\" ); // returns default value(false) if not found session . set ( \"key\" , \"new value\" ); session . string ( \"any-type\" ); // return any type as string representation session . remove ( \"key\" ); session . keys (); // return list of keys Session objects are shared between concurrent requests, this means we can perform atomic operations and even lock the object. session . apply ( \"views\" , []( int v ){ return v + 1 ;}); // this operation is always atomic, no way to get a data race session . mutex (). lock (); // manually lock session","title":"Usage"},{"location":"guides/included-middleware/#expiration","text":"Expiration can happen either by the cookie expiring or the store deleting \"old\" data. By default, cookies expire after 30 days. This can be changed with the cookie option in the Session constructor. crow::FileStore automatically supports deleting files that are expired (older than 30 days). The expiration age can also be changed in the constructor. The session expiration can be postponed. This will make the Session issue a new cookie and make the store acknowledge the new expiration time. session . refresh_expiration ()","title":"Expiration"},{"location":"guides/included-middleware/#cookies","text":"Include: crow/middlewares/cookie_parser.h Examples: examples/middlewares/example_cookies.cpp This middleware allows to read and write cookies by using CookieParser . Once enabled, it parses all incoming cookies. Cookies can be read and written with the middleware context. All cookie attributes can be changed as well. auto & ctx = app . get_context < crow :: CookieParser > ( request ); std :: string value = ctx . get_cookie ( \"key\" ); ctx . set_cookie ( \"key\" , \"value\" ) . path ( \"/\" ) . max_age ( 120 ); Note Make sure CookieParser is listed before any other middleware that relies on it.","title":"Cookies"},{"location":"guides/included-middleware/#cors","text":"Include: crow/middlewares/cors.h Examples: examples/middlewares/example_cors.cpp This middleware allows to set CORS policies by using CORSHandler . Once enabled, it will apply the default CORS rules globally. The CORS rules can be modified by first getting the middleware via auto & cors = app . get_middleware < crow :: CORSHandler > (); . The rules can be set per URL prefix using prefix() , per blueprint using blueprint() , or globally via global() . These will return a CORSRules object which contains the actual rules for the prefix, blueprint, or application. For more details go here . CORSRules can be modified using the methods origin() , methods() , headers() , max_age() , allow_credentials() , or ignore() . For more details on these methods and what default values they take go here . auto & cors = app . get_middleware < crow :: CORSHandler > (); cors . global () . headers ( \"X-Custom-Header\" , \"Upgrade-Insecure-Requests\" ) . methods ( \"POST\" _method , \"GET\" _method ) . prefix ( \"/cors\" ) . origin ( \"example.com\" );","title":"CORS"},{"location":"guides/json/","text":"Crow has built in support for JSON data. type \u00b6 The types of values that rvalue and wvalue can take are as follows: False : from type bool . True : from type bool . Number Floating_point : from type double . Signed_integer : from type int . Unsigned_integer : from type unsigned int . String : from type std::string . List : from type std::vector . Object : from type crow::json::wvalue or crow::json::rvalue . This last type means that rvalue or wvalue can have keys. rvalue \u00b6 JSON read value, used for taking a JSON string and parsing it into crow::json . You can read individual items of the rvalue, but you cannot add items to it. To do that, you need to convert it to a wvalue , which can be done by simply writing crow :: json :: wvalue wval ( rval ); (assuming rval is your rvalue ). For more info on read values go here . wvalue \u00b6 JSON write value, used for creating, editing and converting JSON to a string. Note setting a wvalue to object type can be done by simply assigning a value to whatever string key you like, something like wval [ \"key1\" ] = val1 ; . Keep in mind that val1 can be any of the above types. A wvalue can be treated as an object or even a list (setting a value by using json[3] = 32 for example). Please note that this will remove the data in the value if it isn't of List type. Warning JSON does not allow floating point values like NaN or INF , Crow will output null instead of NaN or INF when converting wvalue to a string. ( {\"Key\": NaN} becomes {\"Key\": null} ) Additionally, a wvalue can be initialized as an object using an initializer list, an example object would be wvalue x = {{\"a\", 1}, {\"b\", 2}} . Or as a list using wvalue x = json::wvalue::list({1, 2, 3}) , lists can include any type that wvalue supports. An object type wvalue uses std::unordered_map by default, if you want to have your returned wvalue key value pairs be sorted (using std::map ) you can add #define CROW_JSON_USE_MAP to the top of your program. A JSON wvalue can be returned directly inside a route handler, this will cause the content-type header to automatically be set to Application/json and the JSON value will be converted to string and placed in the response body. For more information go to Routes . For more info on write values go here . Note Crow's json exceptions can be disabled by using the #define CROW_JSON_NO_ERROR_CHECK macro. This should increase the program speed with the drawback of having unexpected behavious when used incorrectly (e.g. by attempting to parse an invalid json object).","title":"JSON"},{"location":"guides/json/#type","text":"The types of values that rvalue and wvalue can take are as follows: False : from type bool . True : from type bool . Number Floating_point : from type double . Signed_integer : from type int . Unsigned_integer : from type unsigned int . String : from type std::string . List : from type std::vector . Object : from type crow::json::wvalue or crow::json::rvalue . This last type means that rvalue or wvalue can have keys.","title":"type"},{"location":"guides/json/#rvalue","text":"JSON read value, used for taking a JSON string and parsing it into crow::json . You can read individual items of the rvalue, but you cannot add items to it. To do that, you need to convert it to a wvalue , which can be done by simply writing crow :: json :: wvalue wval ( rval ); (assuming rval is your rvalue ). For more info on read values go here .","title":"rvalue"},{"location":"guides/json/#wvalue","text":"JSON write value, used for creating, editing and converting JSON to a string. Note setting a wvalue to object type can be done by simply assigning a value to whatever string key you like, something like wval [ \"key1\" ] = val1 ; . Keep in mind that val1 can be any of the above types. A wvalue can be treated as an object or even a list (setting a value by using json[3] = 32 for example). Please note that this will remove the data in the value if it isn't of List type. Warning JSON does not allow floating point values like NaN or INF , Crow will output null instead of NaN or INF when converting wvalue to a string. ( {\"Key\": NaN} becomes {\"Key\": null} ) Additionally, a wvalue can be initialized as an object using an initializer list, an example object would be wvalue x = {{\"a\", 1}, {\"b\", 2}} . Or as a list using wvalue x = json::wvalue::list({1, 2, 3}) , lists can include any type that wvalue supports. An object type wvalue uses std::unordered_map by default, if you want to have your returned wvalue key value pairs be sorted (using std::map ) you can add #define CROW_JSON_USE_MAP to the top of your program. A JSON wvalue can be returned directly inside a route handler, this will cause the content-type header to automatically be set to Application/json and the JSON value will be converted to string and placed in the response body. For more information go to Routes . For more info on write values go here . Note Crow's json exceptions can be disabled by using the #define CROW_JSON_NO_ERROR_CHECK macro. This should increase the program speed with the drawback of having unexpected behavious when used incorrectly (e.g. by attempting to parse an invalid json object).","title":"wvalue"},{"location":"guides/logging/","text":"Crow comes with a simple and easy to use logging system. Note Currently Crow's Logger is not linked to the Crow application, meaning if an executable has more than one Crow application they'll be sharing any variables or classes relating to Logging. Setting up logging level \u00b6 You can set up the level at which crow displays logs by using the app's loglevel(crow::LogLevel) method. The available log levels are as follows (please not that setting a level will also display all logs below this level): Debug Info Warning Error Critical To set a logLevel, just use app . loglevel ( crow :: LogLevel :: Warning ) , This will not show any debug or info logs. It will however still show error and critical logs. Note Setting the Macro CROW_ENABLE_DEBUG during compilation will also set the log level to Debug (unless otherwise set using loglevel() ). Writing a log \u00b6 Writing a log is as simple as CROW_LOG_ < LOG LEVEL > << \"Hello\" ; (replace<LOG LEVEL> with the actual level in all caps, so you have CROW_LOG_WARNING ). Note Log times are reported in GMT timezone by default. This is because HTTP requires all reported times for requests and responses to be in GMT. This can be changed by using the macro CROW_USE_LOCALTIMEZONE which will set only the log timezone to the server's local timezone. Creating A custom logger \u00b6 v1.0 Assuming you have an existing logger or Crow's default format just doesn't work for you. Crow allows you to use a custom logger for any log made using the CROW_LOG_<LOG LEVEL> macro. All you need is a class extending crow :: ILogHandler containing the method void log ( std :: string , crow :: LogLevel ) . Once you have your custom logger, you need to set it via crow :: logger :: setHandler ( & MyLogger ); . Here's a full example: class CustomLogger : public crow :: ILogHandler { public : CustomLogger () {} void log ( std :: string message , crow :: LogLevel /*level*/ ) { // \"message\" doesn't contain the timestamp and loglevel // prefix the default logger does and it doesn't end // in a newline. std :: cerr << message << std :: endl ; } }; int main ( int argc , char ** argv ) { CustomLogger logger ; crow :: logger :: setHandler ( & logger ); crow :: SimpleApp app ; CROW_ROUTE ( app , \"/\" )([]() { return \"Hello\" ; }); app . run (); }","title":"Logging"},{"location":"guides/logging/#setting-up-logging-level","text":"You can set up the level at which crow displays logs by using the app's loglevel(crow::LogLevel) method. The available log levels are as follows (please not that setting a level will also display all logs below this level): Debug Info Warning Error Critical To set a logLevel, just use app . loglevel ( crow :: LogLevel :: Warning ) , This will not show any debug or info logs. It will however still show error and critical logs. Note Setting the Macro CROW_ENABLE_DEBUG during compilation will also set the log level to Debug (unless otherwise set using loglevel() ).","title":"Setting up logging level"},{"location":"guides/logging/#writing-a-log","text":"Writing a log is as simple as CROW_LOG_ < LOG LEVEL > << \"Hello\" ; (replace<LOG LEVEL> with the actual level in all caps, so you have CROW_LOG_WARNING ). Note Log times are reported in GMT timezone by default. This is because HTTP requires all reported times for requests and responses to be in GMT. This can be changed by using the macro CROW_USE_LOCALTIMEZONE which will set only the log timezone to the server's local timezone.","title":"Writing a log"},{"location":"guides/logging/#creating-a-custom-logger","text":"v1.0 Assuming you have an existing logger or Crow's default format just doesn't work for you. Crow allows you to use a custom logger for any log made using the CROW_LOG_<LOG LEVEL> macro. All you need is a class extending crow :: ILogHandler containing the method void log ( std :: string , crow :: LogLevel ) . Once you have your custom logger, you need to set it via crow :: logger :: setHandler ( & MyLogger ); . Here's a full example: class CustomLogger : public crow :: ILogHandler { public : CustomLogger () {} void log ( std :: string message , crow :: LogLevel /*level*/ ) { // \"message\" doesn't contain the timestamp and loglevel // prefix the default logger does and it doesn't end // in a newline. std :: cerr << message << std :: endl ; } }; int main ( int argc , char ** argv ) { CustomLogger logger ; crow :: logger :: setHandler ( & logger ); crow :: SimpleApp app ; CROW_ROUTE ( app , \"/\" )([]() { return \"Hello\" ; }); app . run (); }","title":"Creating A custom logger"},{"location":"guides/middleware/","text":"Middleware is used for altering and inspecting requests before and after calling the handler. In Crow it's very similar to middleware in other web frameworks. All middleware is registered in the Crow application crow :: App < FirstMW , SecondMW , ThirdMW > app ; and is called in this specified order. Any middleware requires the following 3 members: A context struct for storing request local data. A before_handle method, which is called before the handler. A after_handle method, which is called after the handler. Warning As soon as response.end() is called, no other handlers and middleware is run, except for after_handlers of already visited middleware. Example \u00b6 A middleware that can be used to guard admin handlers struct AdminAreaGuard { struct context {}; void before_handle ( crow :: request & req , crow :: response & res , context & ctx ) { if ( req . remote_ip_address != ADMIN_IP ) { res . code = 403 ; res . end (); } } void after_handle ( crow :: request & req , crow :: response & res , context & ctx ) {} }; before_handle and after_handle \u00b6 There are two possible signatures for before_handle and after_handle if you only need to access this middleware's context. void before_handle ( request & req , response & res , context & ctx ) To get access to other middlewares context template < typename AllContext > void before_handle ( request & req , response & res , context & ctx , AllContext & all_ctx ) { auto other_ctx = all_ctx . template get < OtherMiddleware > (); } Local middleware \u00b6 By default, every middleware is called for each request. If you want to enable middleware for specific handlers or blueprints, you have to extend it from crow::ILocalMiddleware struct LocalMiddleware : crow :: ILocalMiddleware { After this, you can enable it for specific handlers CROW_ROUTE ( app , \"/with_middleware\" ) . CROW_MIDDLEWARES ( app , LocalMiddleware ) ([]() { return \"Hello world!\" ; }); or blueprints Blueprint bp ( \"with_middleware\" ); bp . CROW_MIDDLEWARES ( app , FistLocalMiddleware , SecondLocalMiddleware ); Warning Local and global middleware are called separately. First all global middleware is run, then all enabled local middleware for the current handler is run. In both cases middleware is called strongly in the order listed in the Crow application.","title":"Middleware"},{"location":"guides/middleware/#example","text":"A middleware that can be used to guard admin handlers struct AdminAreaGuard { struct context {}; void before_handle ( crow :: request & req , crow :: response & res , context & ctx ) { if ( req . remote_ip_address != ADMIN_IP ) { res . code = 403 ; res . end (); } } void after_handle ( crow :: request & req , crow :: response & res , context & ctx ) {} };","title":"Example"},{"location":"guides/middleware/#before_handle-and-after_handle","text":"There are two possible signatures for before_handle and after_handle if you only need to access this middleware's context. void before_handle ( request & req , response & res , context & ctx ) To get access to other middlewares context template < typename AllContext > void before_handle ( request & req , response & res , context & ctx , AllContext & all_ctx ) { auto other_ctx = all_ctx . template get < OtherMiddleware > (); }","title":"before_handle and after_handle"},{"location":"guides/middleware/#local-middleware","text":"By default, every middleware is called for each request. If you want to enable middleware for specific handlers or blueprints, you have to extend it from crow::ILocalMiddleware struct LocalMiddleware : crow :: ILocalMiddleware { After this, you can enable it for specific handlers CROW_ROUTE ( app , \"/with_middleware\" ) . CROW_MIDDLEWARES ( app , LocalMiddleware ) ([]() { return \"Hello world!\" ; }); or blueprints Blueprint bp ( \"with_middleware\" ); bp . CROW_MIDDLEWARES ( app , FistLocalMiddleware , SecondLocalMiddleware ); Warning Local and global middleware are called separately. First all global middleware is run, then all enabled local middleware for the current handler is run. In both cases middleware is called strongly in the order listed in the Crow application.","title":"Local middleware"},{"location":"guides/multipart/","text":"v0.2 Multipart is a way of forming HTTP requests or responses to contain multiple distinct parts. Such an approach allows a request to contain multiple different pieces of data with potentially conflicting data types in a single response payload. It is typically used either in HTML forms, or when uploading multiple files. How multipart messages work \u00b6 The structure of a multipart request is typically consistent of: A Header: Typically multipart/form-data;boundary=<boundary> , This defines the HTTP message as being multipart, as well as defining the separator used to distinguish the different parts. 1 or more parts: --<boundary> Part header: typically content-disposition: mime/type; name=\"<fieldname>\" ( mime/type should be replaced with the actual mime-type), can also contain a filename property (separated from the rest by a ; and structured similarly to the name property) Value --<boundary>-- Multipart messages in Crow \u00b6 Crow supports multipart requests and responses though crow::multipart::message . A message can be created either by defining the headers, boundary, and individual parts and using them to create the message. or simply by reading a crow::request . Once a multipart message has been made, the individual parts can be accessed throughout msg.parts , parts is an std::vector . v1.0 Part headers are organized in a similar way to request and response headers, and can be retrieved via crow::multipart::get_header_object(\"header-key\") . This function returns a crow::multipart::header object. The message's individual body parts can be accessed by name using msg.get_part_by_name(\"part-name\") . For more info on Multipart messages, go here","title":"Multipart"},{"location":"guides/multipart/#how-multipart-messages-work","text":"The structure of a multipart request is typically consistent of: A Header: Typically multipart/form-data;boundary=<boundary> , This defines the HTTP message as being multipart, as well as defining the separator used to distinguish the different parts. 1 or more parts: --<boundary> Part header: typically content-disposition: mime/type; name=\"<fieldname>\" ( mime/type should be replaced with the actual mime-type), can also contain a filename property (separated from the rest by a ; and structured similarly to the name property) Value --<boundary>--","title":"How multipart messages work"},{"location":"guides/multipart/#multipart-messages-in-crow","text":"Crow supports multipart requests and responses though crow::multipart::message . A message can be created either by defining the headers, boundary, and individual parts and using them to create the message. or simply by reading a crow::request . Once a multipart message has been made, the individual parts can be accessed throughout msg.parts , parts is an std::vector . v1.0 Part headers are organized in a similar way to request and response headers, and can be retrieved via crow::multipart::get_header_object(\"header-key\") . This function returns a crow::multipart::header object. The message's individual body parts can be accessed by name using msg.get_part_by_name(\"part-name\") . For more info on Multipart messages, go here","title":"Multipart messages in Crow"},{"location":"guides/proxies/","text":"You can set Crow up behind any HTTP proxy of your liking, but we will be focusing specifically on 2 of the most popular web server software solutions, Apache2 and Nginx. A reverse proxy allows you to use Crow without exposing it directly to the internet. It also allows you to, for example, have crow run on a certain specific domain name, subdomain, or even a path, such as domain.abc/crow . We advise that you set crow up behind some form of reverse proxy if you plan on running a production Crow server that isn't local. SSL When using a proxy, make sure that you do not compile Crow with SSL enabled. SSL should be handled by the proxy. Apache2 \u00b6 Assuming you have both Apache2 and the modules proxy , proxy_http , proxy_html (if you plan on serving HTML pages), and proxy_wstunnel (if you plan on using websockets). You will need to enable those modules, which you can do using the following commands: a2enmod proxy a2enmod proxy_http a2enmod proxy_html a2enmod proxy_wstunnel Next up you'll need to change your configuration (default is /etc/apache2/sites-enabled/000-default.conf ) and add the following lines (replace localhost and 40080 with the address and port you defined for your Crow App): ProxyPass / http://localhost:40080 ProxyPassReverse / http://localhost:40080 If you want crow to run in a subdirectory (such as domain.abc/crow ) you can use the location tag: <Location \"/crow\"> ProxyPass http://localhost:40080 ProxyPassReverse http://localhost:40080 </Location> Note If you're using an Arch Linux based OS. You will have to access /etc/httpd/conf/httpd.conf to enable modules and change configuration. Nginx \u00b6 Setting Nginx up is slightly simpler than Apache, all you need is the Nginx package itself. Once you've installed it, go to the configuration file (usually a .conf file located in /etc/nginx ) and add the following lines to your server section (replace localhost and 40080 with the address and port you defined for your Crow App): location / { proxy_pass http://localhost:40080/; proxy_http_version 1.1; } Remember to remove or comment out any existing location / section. Alternatively, if you want to use a subdirectory, you can simply change the location parameter as such: location /crow/ { proxy_pass http://localhost:40080/; proxy_http_version 1.1; }","title":"Proxies"},{"location":"guides/proxies/#apache2","text":"Assuming you have both Apache2 and the modules proxy , proxy_http , proxy_html (if you plan on serving HTML pages), and proxy_wstunnel (if you plan on using websockets). You will need to enable those modules, which you can do using the following commands: a2enmod proxy a2enmod proxy_http a2enmod proxy_html a2enmod proxy_wstunnel Next up you'll need to change your configuration (default is /etc/apache2/sites-enabled/000-default.conf ) and add the following lines (replace localhost and 40080 with the address and port you defined for your Crow App): ProxyPass / http://localhost:40080 ProxyPassReverse / http://localhost:40080 If you want crow to run in a subdirectory (such as domain.abc/crow ) you can use the location tag: <Location \"/crow\"> ProxyPass http://localhost:40080 ProxyPassReverse http://localhost:40080 </Location> Note If you're using an Arch Linux based OS. You will have to access /etc/httpd/conf/httpd.conf to enable modules and change configuration.","title":"Apache2"},{"location":"guides/proxies/#nginx","text":"Setting Nginx up is slightly simpler than Apache, all you need is the Nginx package itself. Once you've installed it, go to the configuration file (usually a .conf file located in /etc/nginx ) and add the following lines to your server section (replace localhost and 40080 with the address and port you defined for your Crow App): location / { proxy_pass http://localhost:40080/; proxy_http_version 1.1; } Remember to remove or comment out any existing location / section. Alternatively, if you want to use a subdirectory, you can simply change the location parameter as such: location /crow/ { proxy_pass http://localhost:40080/; proxy_http_version 1.1; }","title":"Nginx"},{"location":"guides/query-string/","text":"A query string is the part of the URL that comes after a ? character, it is usually formatted as key=value&otherkey=othervalue . Crow supports query strings through crow::request::url_params . The object is of type crow::query_string and can has the following functions: get(name) \u00b6 Returns the value (as char*) based on the given key (or name). Returns nullptr if the key is not found. pop(name) \u00b6 v0.3 Works the same as get , but removes the returned value. Note crow::request::url_params is a const value, therefore for pop (also pop_list and pop_dict) to work, a copy needs to be made. get_list(name) \u00b6 A URL can be http://example.com?key[]=value1&key[]=value2&key[]=value3 . Using get_list(\"key\") on such a URL returns an std::vector<std::string> containing [value1, value2, value3] . get_list ( \"key\" , false ) can be used to parse http://example.com?key=value1&key=value2&key=value3 pop_list(name) \u00b6 v0.3 Works the same as get_list but removes all instances of values having the given key ( use_brackets is also available here). get_dict(name) \u00b6 Returns an std::unordered_map<std::string, std::string> from a query string such as ?key[sub_key1]=value1&key[sub_key2]=value2&key[sub_key3]=value3 . The key in the map is what's in the brackets ( sub_key1 for example), and the value being what's after the = sign ( value1 ). The name passed to the function is not part of the returned value. pop_dict(name) \u00b6 v0.3 Works the same as get_dict but removing the values from the query string. Warning if your query string contains both a list and dictionary with the same key, it is best to use pop_list before either get_dict or pop_dict , since a map cannot contain more than one value per key, each item in the list will override the previous and only the last will remain with an empty key. For more information take a look here .","title":"Query Strings"},{"location":"guides/query-string/#getname","text":"Returns the value (as char*) based on the given key (or name). Returns nullptr if the key is not found.","title":"get(name)"},{"location":"guides/query-string/#popname","text":"v0.3 Works the same as get , but removes the returned value. Note crow::request::url_params is a const value, therefore for pop (also pop_list and pop_dict) to work, a copy needs to be made.","title":"pop(name)"},{"location":"guides/query-string/#get_listname","text":"A URL can be http://example.com?key[]=value1&key[]=value2&key[]=value3 . Using get_list(\"key\") on such a URL returns an std::vector<std::string> containing [value1, value2, value3] . get_list ( \"key\" , false ) can be used to parse http://example.com?key=value1&key=value2&key=value3","title":"get_list(name)"},{"location":"guides/query-string/#pop_listname","text":"v0.3 Works the same as get_list but removes all instances of values having the given key ( use_brackets is also available here).","title":"pop_list(name)"},{"location":"guides/query-string/#get_dictname","text":"Returns an std::unordered_map<std::string, std::string> from a query string such as ?key[sub_key1]=value1&key[sub_key2]=value2&key[sub_key3]=value3 . The key in the map is what's in the brackets ( sub_key1 for example), and the value being what's after the = sign ( value1 ). The name passed to the function is not part of the returned value.","title":"get_dict(name)"},{"location":"guides/query-string/#pop_dictname","text":"v0.3 Works the same as get_dict but removing the values from the query string. Warning if your query string contains both a list and dictionary with the same key, it is best to use pop_list before either get_dict or pop_dict , since a map cannot contain more than one value per key, each item in the list will override the previous and only the last will remain with an empty key. For more information take a look here .","title":"pop_dict(name)"},{"location":"guides/routes/","text":"Routes define what happens when your client connects to a certain URL. Macro \u00b6 CROW_ROUTE(app, url) Can be replaced with app . route < crow :: black_magick :: get_parameter_tag ( url ) > ( url ) or app . route_dynamic ( url ) if you're using VS2013 or want runtime URL evaluation. Although this usage is NOT recommended. App \u00b6 Which app class to assign the route to. Path (URL) \u00b6 Which relative path is assigned to the route. Using /hello means the client will need to access http://example.com/hello in order to access the route. A path can have parameters, for example /hello/<int> will allow a client to input an int into the url which will be in the handler (something like http://example.com/hello/42 ). Parameters can be <int> , <uint> , <double> , <string> , or <path> . It's worth noting that the parameters also need to be defined in the handler, an example of using parameters would be to add 2 numbers based on input: CROW_ROUTE ( app , \"/add/<int>/<int>\" ) ([]( int a , int b ) { return std :: to_string ( a + b ); }); you can see the first <int> is defined as a and the second as b . If you were to run this and call http://example.com/add/1/2 , the result would be a page with 3 . Exciting! Methods \u00b6 You can change the HTTP methods the route uses from just the default GET by using method() , your route macro should look like CROW_ROUTE(app, \"/add/<int>/<int>\").methods(crow::HTTPMethod::GET, crow::HTTPMethod::PATCH) or CROW_ROUTE(app, \"/add/<int>/<int>\").methods(\"GET\"_method, \"PATCH\"_method) . Note Crow handles OPTIONS method automatically. The HEAD method is handled automatically unless defined in a route. Adding OPTIONS to a route's methods has no effect. Crow defines the following methods: DELETE GET HEAD POST PUT CONNECT OPTIONS TRACE PATCH PURGE COPY LOCK MKCOL MOVE PROPFIND PROPPATCH SEARCH UNLOCK BIND REBIND UNBIND ACL REPORT MKACTIVITY CHECKOUT MERGE SEARCH NOTIFY SUBSCRIBE UNSUBSCRIBE MKCALENDAR LINK UNLINK SOURCE Handler \u00b6 Basically a piece of code that gets executed whenever the client calls the associated route, usually in the form of a lambda expression . It can be as simple as ([](){ return \"Hello World\" }) . Request \u00b6 Handlers can also use information from the request by adding it as a parameter ([]( const crow :: request & req ){...}) . You can also access the URL parameters in the handler using req . url_params . get ( \"param_name\" ); . If the parameter doesn't exist, nullptr is returned. Note master parameters inside the body can be parsed using req . get_body_params (); . which is useful for requests of type application/x-www-form-urlencoded . Its format is similar to url_params . For more information on crow::request go here . Response \u00b6 Crow also provides the ability to define a response in the parameters by using ([]( crow :: response & res ){...}) . Please note that in order to return a response defined as a parameter you'll need to use res.end(); . Alternatively, you can define the response in the body and return it ( ([](){ return crow :: response ()}) ). For more information on crow::response go here . Crow defines the following status codes: 100 Continue 101 Switching Protocols 200 OK 201 Created 202 Accepted 203 Non-Authoritative Information 204 No Content 205 Reset Content 206 Partial Content 300 Multiple Choices 301 Moved Permanently 302 Found 303 See Other 304 Not Modified 307 Temporary Redirect 308 Permanent Redirect 400 Bad Request 401 Unauthorized 403 Forbidden 404 Not Found 405 Method Not Allowed 407 Proxy Authentication Required 409 Conflict 410 Gone 413 Payload Too Large 415 Unsupported Media Type 416 Range Not Satisfiable 417 Expectation Failed 428 Precondition Required 429 Too Many Requests 451 Unavailable For Legal Reasons 500 Internal Server Error 501 Not Implemented 502 Bad Gateway 503 Service Unavailable 504 Gateway Timeout 506 Variant Also Negotiates Note If your status code is not defined in the list above (e.g. crow::response(123) ) Crow will return 500 Internal Server Error instead. Return statement \u00b6 A crow::response is very strictly tied to a route. If you can have something in a response constructor, you can return it in a handler. The main return type is std::string , although you could also return a crow::json::wvalue or crow::multipart::message directly. For more information on the specific constructors for a crow::response go here . Returning custom classes \u00b6 v0.3 If you have your own class you want to return (without converting it to string and returning that), you can use the crow::returnable class. to use the returnable class, you only need your class to publicly extend crow::returnable , add a dump() method that returns your class as an std::string , and add a constructor that has a Content-Type header as a string argument. Your class should look like the following: class a : public crow :: returnable { a () : returnable ( \"text/plain\" ){}; ... ... ... std :: string dump () override { return this . as_string (); } } Response codes \u00b6 v1.0 Instead of assigning a response code, you can use the crow::status enum, for example you can replace crow::response(200) with crow::response(crow::status::OK) Catchall routes \u00b6 v0.3 By default, any request that Crow can't find a route for will return a simple 404 response. You can change that to return a default route using the CROW_CATCHALL_ROUTE(app) macro. Defining it is identical to a normal route, even when it comes to the const crow::request& and crow::response& parameters being optional. Note For versions higher than 0.3 (excluding patches), Catchall routes handle 404 and 405 responses. The default response will contain the code 404 or 405.","title":"Routes"},{"location":"guides/routes/#macro","text":"CROW_ROUTE(app, url) Can be replaced with app . route < crow :: black_magick :: get_parameter_tag ( url ) > ( url ) or app . route_dynamic ( url ) if you're using VS2013 or want runtime URL evaluation. Although this usage is NOT recommended.","title":"Macro"},{"location":"guides/routes/#app","text":"Which app class to assign the route to.","title":"App"},{"location":"guides/routes/#path-url","text":"Which relative path is assigned to the route. Using /hello means the client will need to access http://example.com/hello in order to access the route. A path can have parameters, for example /hello/<int> will allow a client to input an int into the url which will be in the handler (something like http://example.com/hello/42 ). Parameters can be <int> , <uint> , <double> , <string> , or <path> . It's worth noting that the parameters also need to be defined in the handler, an example of using parameters would be to add 2 numbers based on input: CROW_ROUTE ( app , \"/add/<int>/<int>\" ) ([]( int a , int b ) { return std :: to_string ( a + b ); }); you can see the first <int> is defined as a and the second as b . If you were to run this and call http://example.com/add/1/2 , the result would be a page with 3 . Exciting!","title":"Path (URL)"},{"location":"guides/routes/#methods","text":"You can change the HTTP methods the route uses from just the default GET by using method() , your route macro should look like CROW_ROUTE(app, \"/add/<int>/<int>\").methods(crow::HTTPMethod::GET, crow::HTTPMethod::PATCH) or CROW_ROUTE(app, \"/add/<int>/<int>\").methods(\"GET\"_method, \"PATCH\"_method) . Note Crow handles OPTIONS method automatically. The HEAD method is handled automatically unless defined in a route. Adding OPTIONS to a route's methods has no effect. Crow defines the following methods: DELETE GET HEAD POST PUT CONNECT OPTIONS TRACE PATCH PURGE COPY LOCK MKCOL MOVE PROPFIND PROPPATCH SEARCH UNLOCK BIND REBIND UNBIND ACL REPORT MKACTIVITY CHECKOUT MERGE SEARCH NOTIFY SUBSCRIBE UNSUBSCRIBE MKCALENDAR LINK UNLINK SOURCE","title":"Methods"},{"location":"guides/routes/#handler","text":"Basically a piece of code that gets executed whenever the client calls the associated route, usually in the form of a lambda expression . It can be as simple as ([](){ return \"Hello World\" }) .","title":"Handler"},{"location":"guides/routes/#request","text":"Handlers can also use information from the request by adding it as a parameter ([]( const crow :: request & req ){...}) . You can also access the URL parameters in the handler using req . url_params . get ( \"param_name\" ); . If the parameter doesn't exist, nullptr is returned. Note master parameters inside the body can be parsed using req . get_body_params (); . which is useful for requests of type application/x-www-form-urlencoded . Its format is similar to url_params . For more information on crow::request go here .","title":"Request"},{"location":"guides/routes/#response","text":"Crow also provides the ability to define a response in the parameters by using ([]( crow :: response & res ){...}) . Please note that in order to return a response defined as a parameter you'll need to use res.end(); . Alternatively, you can define the response in the body and return it ( ([](){ return crow :: response ()}) ). For more information on crow::response go here . Crow defines the following status codes: 100 Continue 101 Switching Protocols 200 OK 201 Created 202 Accepted 203 Non-Authoritative Information 204 No Content 205 Reset Content 206 Partial Content 300 Multiple Choices 301 Moved Permanently 302 Found 303 See Other 304 Not Modified 307 Temporary Redirect 308 Permanent Redirect 400 Bad Request 401 Unauthorized 403 Forbidden 404 Not Found 405 Method Not Allowed 407 Proxy Authentication Required 409 Conflict 410 Gone 413 Payload Too Large 415 Unsupported Media Type 416 Range Not Satisfiable 417 Expectation Failed 428 Precondition Required 429 Too Many Requests 451 Unavailable For Legal Reasons 500 Internal Server Error 501 Not Implemented 502 Bad Gateway 503 Service Unavailable 504 Gateway Timeout 506 Variant Also Negotiates Note If your status code is not defined in the list above (e.g. crow::response(123) ) Crow will return 500 Internal Server Error instead.","title":"Response"},{"location":"guides/routes/#return-statement","text":"A crow::response is very strictly tied to a route. If you can have something in a response constructor, you can return it in a handler. The main return type is std::string , although you could also return a crow::json::wvalue or crow::multipart::message directly. For more information on the specific constructors for a crow::response go here .","title":"Return statement"},{"location":"guides/routes/#returning-custom-classes","text":"v0.3 If you have your own class you want to return (without converting it to string and returning that), you can use the crow::returnable class. to use the returnable class, you only need your class to publicly extend crow::returnable , add a dump() method that returns your class as an std::string , and add a constructor that has a Content-Type header as a string argument. Your class should look like the following: class a : public crow :: returnable { a () : returnable ( \"text/plain\" ){}; ... ... ... std :: string dump () override { return this . as_string (); } }","title":"Returning custom classes"},{"location":"guides/routes/#response-codes","text":"v1.0 Instead of assigning a response code, you can use the crow::status enum, for example you can replace crow::response(200) with crow::response(crow::status::OK)","title":"Response codes"},{"location":"guides/routes/#catchall-routes","text":"v0.3 By default, any request that Crow can't find a route for will return a simple 404 response. You can change that to return a default route using the CROW_CATCHALL_ROUTE(app) macro. Defining it is identical to a normal route, even when it comes to the const crow::request& and crow::response& parameters being optional. Note For versions higher than 0.3 (excluding patches), Catchall routes handle 404 and 405 responses. The default response will contain the code 404 or 405.","title":"Catchall routes"},{"location":"guides/ssl/","text":"Crow supports HTTPS though SSL or TLS. Note When mentioning SSL in this documentation, it is often a reference to openSSL, which includes TLS. To enable SSL, first your application needs to define either a .crt and .key files, or a .pem file. Once you have your files, you can add them to your app like this: app . ssl_file ( \"/path/to/cert.crt\" , \"/path/to/keyfile.key\" ) or app . ssl_file ( \"/path/to/pem_file.pem\" ) . Please note that this method can be part of the app method chain, which means it can be followed by .run() or any other method. You also need to define CROW_ENABLE_SSL in your compiler definitions ( g++ main.cpp -DCROW_ENABLE_SSL for example) or set(CROW_FEATURES ssl) in CMakeLists.txt . You can also set your own SSL context (by using asio::ssl::context ctx ) and then applying it via the app . ssl ( ctx ) method. Warning If you plan on using a proxy like Nginx or Apache2, DO NOT use SSL in crow, instead define it in your proxy and keep the connection between the proxy and Crow non-SSL.","title":"SSL"},{"location":"guides/static/","text":"v0.2 A static file is any file that resides in the server's storage. Crow supports returning Static files as responses in 2 ways. Implicit \u00b6 Crow implicitly returns any static files placed in a static directory and any subdirectories, as long as the user calls the endpoint /static/path/to/file . The static folder or endpoint can be changed by defining the macros CROW_STATIC_DIRECTORY \"alternative_directory/\" and CROW_STATIC_ENDPOINT \"/alternative_endpoint/<path>\" . static directory changes the directory in the server's file system, while the endpoint changes the URL that the client needs to access. Explicit \u00b6 You can directly return a static file by using the crow::response method response . set_static_file_info ( \"path/to/file\" ); . The path is relative to the working directory. Warning The path to the file is sanitized by default. it should be fine for most circumstances but if you know what you're doing and need the sanitizer off you can use response . set_static_file_info_unsafe ( \"path/to/file\" ) instead. Note Crow sets the content-type header automatically based on the file's extension, if an extension is unavailable or undefined, Crow uses text/plain , if you'd like to explicitly set a content-type , use response . set_header ( \"content-type\" , \"mime/type\" ); AFTER calling set_static_file_info . Note Please keep in mind that using the set_static_file_info method means any data already in your response body is ignored and not sent to the client.","title":"Static Files"},{"location":"guides/static/#implicit","text":"Crow implicitly returns any static files placed in a static directory and any subdirectories, as long as the user calls the endpoint /static/path/to/file . The static folder or endpoint can be changed by defining the macros CROW_STATIC_DIRECTORY \"alternative_directory/\" and CROW_STATIC_ENDPOINT \"/alternative_endpoint/<path>\" . static directory changes the directory in the server's file system, while the endpoint changes the URL that the client needs to access.","title":"Implicit"},{"location":"guides/static/#explicit","text":"You can directly return a static file by using the crow::response method response . set_static_file_info ( \"path/to/file\" ); . The path is relative to the working directory. Warning The path to the file is sanitized by default. it should be fine for most circumstances but if you know what you're doing and need the sanitizer off you can use response . set_static_file_info_unsafe ( \"path/to/file\" ) instead. Note Crow sets the content-type header automatically based on the file's extension, if an extension is unavailable or undefined, Crow uses text/plain , if you'd like to explicitly set a content-type , use response . set_header ( \"content-type\" , \"mime/type\" ); AFTER calling set_static_file_info . Note Please keep in mind that using the set_static_file_info method means any data already in your response body is ignored and not sent to the client.","title":"Explicit"},{"location":"guides/syste/","text":"Using Systemd allows you to run any executable or script when the system starts. This can be useful when you don't want to re-run your Crow application every single time you restart your server. Writing the Service Unit File \u00b6 In order to have Systemd recognize your application, you need to create a .service file that explains how Systemd should handle your program. To create a service file, you need to go to /etc/systemd/system and create an empty text file with the extension .service , the file name can be anything. Once the file is created, open it using your favorite text editor and add the following: [ Unit ] Description = My revolutionary Crow application Wants = network.target After = syslog.target network-online.target [ Service ] Type = simple ExecStart = /absolute/path/to/your/executable Restart = on-failure RestartSec = 10 KillMode = process [ Install ] WantedBy = multi-user.target You will then need to give the correct permission, this can be done by using the following command (a sudo maybe required): chmod 640 /etc/systemd/system/crowthing.service And that's it! You can now use your systemctl controls to enable , start , stop , or disable your Crow application. If you're not familiar with Systemd, systemctl enable crowthing.service will allow your Crow application to run at startup, start will start it, and the rest is simple.","title":"Systemd run on startup"},{"location":"guides/syste/#writing-the-service-unit-file","text":"In order to have Systemd recognize your application, you need to create a .service file that explains how Systemd should handle your program. To create a service file, you need to go to /etc/systemd/system and create an empty text file with the extension .service , the file name can be anything. Once the file is created, open it using your favorite text editor and add the following: [ Unit ] Description = My revolutionary Crow application Wants = network.target After = syslog.target network-online.target [ Service ] Type = simple ExecStart = /absolute/path/to/your/executable Restart = on-failure RestartSec = 10 KillMode = process [ Install ] WantedBy = multi-user.target You will then need to give the correct permission, this can be done by using the following command (a sudo maybe required): chmod 640 /etc/systemd/system/crowthing.service And that's it! You can now use your systemctl controls to enable , start , stop , or disable your Crow application. If you're not familiar with Systemd, systemctl enable crowthing.service will allow your Crow application to run at startup, start will start it, and the rest is simple.","title":"Writing the Service Unit File"},{"location":"guides/templating/","text":"Templating is when you return an HTML page with custom data. You can probably tell why that's useful. Crow supports mustache for templates through its own implementation crow::mustache . Note Currently Crow's Mustache implementation is not linked to the Crow application, meaning if an executable has more than one Crow application they'll be sharing any variables or classes relating to template loading and compiling. Components of mustache \u00b6 There are 2 components of a mustache template implementation: Page Context Page \u00b6 The HTML page (including the mustache tags). It is usually loaded into crow::mustache::template_t . It needs to be placed in the templates directory which should be directly inside the current working directory of the crow executable. The templates directory is usually called templates , but can be adjusted per Route (via crow::mustache::set_base(\"new_templates_directory\") ), per Blueprint , or globally (via crow::mustache::set_global_base(\"new_templates_directory\"\") ). For more information on how to formulate a template, see this mustache manual . Context \u00b6 A JSON object containing the tags as keys and their values. crow::mustache::context is actually a crow::json::wvalue . Note crow::mustache::context can take a C++ lambda as a value. The lambda needs to take a string as an argument and return a string, such as ctx [ lmd ] = [ & ]( std :: string ){ return \"Hello World\" ;}; . Note The string returned by the lamdba can contain mustache tags, Crow will parse it as any normal template string. Returning a template \u00b6 To return a mustache template, you need to load a page using auto page = crow :: mustache :: load ( \"path/to/template.html\" ); . Or just simply load a string using auto page = crow :: mustache :: compile ( \"my mustache {{value}}\" ); . Keep in mind that the path is relative to the templates directory. Note You can also use auto page = crow :: mustache :: load_text ( \"path/to/template.html\" ); if you want to load a template without mustache processing. Warning The path to the template is sanitized by default. it should be fine for most circumstances but if you know what you're doing and need the sanitizer off you can use crow :: mustache :: load_unsafe () instead. You also need to set up the context by using crow :: mustache :: context ctx ; . Then you need to assign the keys and values, this can be done the same way you assign values to a JSON write value ( ctx[\"key\"] = value; ). With your context and page ready, just return page . render ( ctx ); . This will use the context data to return a filled template. Alternatively you could just render the page without a context using return page . render (); . Note page . render (); returns a crow::returnable class in order to set the Content-Type header. to get a simple string, use page . render_string () instead.","title":"Templating (Mustache)"},{"location":"guides/templating/#components-of-mustache","text":"There are 2 components of a mustache template implementation: Page Context","title":"Components of mustache"},{"location":"guides/templating/#page","text":"The HTML page (including the mustache tags). It is usually loaded into crow::mustache::template_t . It needs to be placed in the templates directory which should be directly inside the current working directory of the crow executable. The templates directory is usually called templates , but can be adjusted per Route (via crow::mustache::set_base(\"new_templates_directory\") ), per Blueprint , or globally (via crow::mustache::set_global_base(\"new_templates_directory\"\") ). For more information on how to formulate a template, see this mustache manual .","title":"Page"},{"location":"guides/templating/#context","text":"A JSON object containing the tags as keys and their values. crow::mustache::context is actually a crow::json::wvalue . Note crow::mustache::context can take a C++ lambda as a value. The lambda needs to take a string as an argument and return a string, such as ctx [ lmd ] = [ & ]( std :: string ){ return \"Hello World\" ;}; . Note The string returned by the lamdba can contain mustache tags, Crow will parse it as any normal template string.","title":"Context"},{"location":"guides/templating/#returning-a-template","text":"To return a mustache template, you need to load a page using auto page = crow :: mustache :: load ( \"path/to/template.html\" ); . Or just simply load a string using auto page = crow :: mustache :: compile ( \"my mustache {{value}}\" ); . Keep in mind that the path is relative to the templates directory. Note You can also use auto page = crow :: mustache :: load_text ( \"path/to/template.html\" ); if you want to load a template without mustache processing. Warning The path to the template is sanitized by default. it should be fine for most circumstances but if you know what you're doing and need the sanitizer off you can use crow :: mustache :: load_unsafe () instead. You also need to set up the context by using crow :: mustache :: context ctx ; . Then you need to assign the keys and values, this can be done the same way you assign values to a JSON write value ( ctx[\"key\"] = value; ). With your context and page ready, just return page . render ( ctx ); . This will use the context data to return a filled template. Alternatively you could just render the page without a context using return page . render (); . Note page . render (); returns a crow::returnable class in order to set the Content-Type header. to get a simple string, use page . render_string () instead.","title":"Returning a template"},{"location":"guides/testing/","text":"Unit tests can be written in 2 ways for a Crow application. The handler method \u00b6 Crow allows users to handle requests that may not come from the network. This is done by calling the handle(req, res) method and providing a request and response objects. Which causes crow to identify and run the appropriate handler, returning the resulting response. 1 2 3 4 5 6 7 8 9 10 11 12 13 CROW_ROUTE ( app , \"/place\" ) ([] { return \"hi\" ; }); app . validate (); //Used to make sure all the route handlers are in order. { request req ; response res ; req . url = \"/place\" ; app . handle ( req , res ); //res will contain a code of 200, and a response body of \"hi\" } Note This method is the simpler of the two and is usually all you really need to test your routes. Warning This method does not send any data, nor does it run any post handle code, so things like static file serving (as far as sending the actual data) or compression cannot be tested using this method. The client method \u00b6 This method involves creating a simple ASIO client that sends the request and receives the response. It is considerably more complex than the earlier method, but it is both more realistic and includes post handle operations. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 static char buf [ 2048 ]; SimpleApp app ; CROW_ROUTE ( app , \"/\" )([] { return \"A\" ; }); auto _ = async ( launch :: async ,[ & ] { app1 . bindaddr ( \"127.0.0.1\" ). port ( 45451 ). run (); }); app . wait_for_server_start (); std :: string sendmsg = \"GET / \\r\\n Content-Length:3 \\r\\n X-HeaderTest: 123 \\r\\n\\r\\n A=B \\r\\n \" ; asio :: io_service is ; { asio :: ip :: tcp :: socket c ( is ); c . connect ( asio :: ip :: tcp :: endpoint ( asio :: ip :: address :: from_string ( \"127.0.0.1\" ), 45451 )); c . send ( asio :: buffer ( sendmsg )); size_t recved = c . receive ( asio :: buffer ( buf , 2048 )); CHECK ( 'A' == buf [ recved - 1 ]); //This is specific to catch2 testing library, but it should give a general idea of how to read the response. } app . stop (); //THIS MUST RUN } The first part is straightforward, create an app and add a route. The second part is launching the app asynchronously and waiting until it starts. The third is formulating our HTTP request string, the format is: METHOD / Content-Length:123 header1:value1 header2:value2 BODY Next an io_service is created, then a TCP socket is created with the io_service and is connected to the application. Then send the HTTP request string through the socket inside a buffer, and read the result into the buffer in line 1 . Finally check the result against the expected one. Warning Be absolutely sure that the line app.stop() runs, whether the test fails or succeeds. Not running it WILL CAUSE OTHER TESTS TO FAIL AND THE TEST TO HANG UNTIL THE PROCESS IS TERMINATED.","title":"Writing Tests"},{"location":"guides/testing/#the-handler-method","text":"Crow allows users to handle requests that may not come from the network. This is done by calling the handle(req, res) method and providing a request and response objects. Which causes crow to identify and run the appropriate handler, returning the resulting response. 1 2 3 4 5 6 7 8 9 10 11 12 13 CROW_ROUTE ( app , \"/place\" ) ([] { return \"hi\" ; }); app . validate (); //Used to make sure all the route handlers are in order. { request req ; response res ; req . url = \"/place\" ; app . handle ( req , res ); //res will contain a code of 200, and a response body of \"hi\" } Note This method is the simpler of the two and is usually all you really need to test your routes. Warning This method does not send any data, nor does it run any post handle code, so things like static file serving (as far as sending the actual data) or compression cannot be tested using this method.","title":"The handler method"},{"location":"guides/testing/#the-client-method","text":"This method involves creating a simple ASIO client that sends the request and receives the response. It is considerably more complex than the earlier method, but it is both more realistic and includes post handle operations. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 static char buf [ 2048 ]; SimpleApp app ; CROW_ROUTE ( app , \"/\" )([] { return \"A\" ; }); auto _ = async ( launch :: async ,[ & ] { app1 . bindaddr ( \"127.0.0.1\" ). port ( 45451 ). run (); }); app . wait_for_server_start (); std :: string sendmsg = \"GET / \\r\\n Content-Length:3 \\r\\n X-HeaderTest: 123 \\r\\n\\r\\n A=B \\r\\n \" ; asio :: io_service is ; { asio :: ip :: tcp :: socket c ( is ); c . connect ( asio :: ip :: tcp :: endpoint ( asio :: ip :: address :: from_string ( \"127.0.0.1\" ), 45451 )); c . send ( asio :: buffer ( sendmsg )); size_t recved = c . receive ( asio :: buffer ( buf , 2048 )); CHECK ( 'A' == buf [ recved - 1 ]); //This is specific to catch2 testing library, but it should give a general idea of how to read the response. } app . stop (); //THIS MUST RUN } The first part is straightforward, create an app and add a route. The second part is launching the app asynchronously and waiting until it starts. The third is formulating our HTTP request string, the format is: METHOD / Content-Length:123 header1:value1 header2:value2 BODY Next an io_service is created, then a TCP socket is created with the io_service and is connected to the application. Then send the HTTP request string through the socket inside a buffer, and read the result into the buffer in line 1 . Finally check the result against the expected one. Warning Be absolutely sure that the line app.stop() runs, whether the test fails or succeeds. Not running it WILL CAUSE OTHER TESTS TO FAIL AND THE TEST TO HANG UNTIL THE PROCESS IS TERMINATED.","title":"The client method"},{"location":"guides/websockets/","text":"Websockets are a way of connecting a client and a server without the request response nature of HTTP. Routes \u00b6 To create a websocket in Crow, you need a websocket route. A websocket route differs from a normal route quite a bit. It uses A slightly altered CROW_WEBSOCKET_ROUTE(app, \"/url\") macro, which is then followed by a series of methods (with handlers inside) for each event. These are (sorted by order of execution): onaccept ([ & ]( const crow :: request & req , void ** userdata ){ handler code goes here }) onopen ([ & ]( crow :: websocket :: connection & conn ){ handler code goes here }) onmessage ([ & ]( crow :: websocket :: connection & conn , const std :: string & message , bool is_binary ){ handler code goes here }) onerror ([ & ]( crow :: websocket :: connection & conn , const std :: string & error_message ){ handler code goes here }) onclose ([ & ]( crow :: websocket :: connection & conn , const std :: string & reason ){ handler code goes here }) Note onaccept must return a boolean. In case false is returned, the connection is shut down, deleted, and no further communication is done. Warning By default, Crow allows Clients to send unmasked websocket messages, which is useful for debugging but goes against the protocol specification. Production Crow applications should enforce the protocol by adding #define CROW_ENFORCE_WS_SPEC to their source code. These event methods and their handlers can be chained. The full Route should look similar to this: CROW_ROUTE ( app , \"/ws\" ) . websocket () . onopen ([ & ]( crow :: websocket :: connection & conn ){ do_something (); }) . onclose ([ & ]( crow :: websocket :: connection & conn , const std :: string & reason ){ do_something (); }) . onmessage ([ & ]( crow :: websocket :: connection & /*conn*/ , const std :: string & data , bool is_binary ){ if ( is_binary ) do_something ( data ); else do_something_else ( data ); }); Maximum payload size \u00b6 master The maximum payload size that a connection accepts can be adjusted either globally by using app . websocket_max_payload ( < value in bytes > ) or per route by using CROW_WEBSOCKET_ROUTE ( app , \"/url\" ). max_payload ( < value in bytes > ) . In case a message was sent that exceeded the limit. The connection would be shut down and onerror would be triggered. Note By default, This limit is disabled. To disable the global setting in specific routes, you only need to call CROW_WEBSOCKET_ROUTE ( app , \"/url\" ). max_payload ( UINT64_MAX ) . For more info about websocket routes go here . For more info about websocket connections go here .","title":"Websockets"},{"location":"guides/websockets/#routes","text":"To create a websocket in Crow, you need a websocket route. A websocket route differs from a normal route quite a bit. It uses A slightly altered CROW_WEBSOCKET_ROUTE(app, \"/url\") macro, which is then followed by a series of methods (with handlers inside) for each event. These are (sorted by order of execution): onaccept ([ & ]( const crow :: request & req , void ** userdata ){ handler code goes here }) onopen ([ & ]( crow :: websocket :: connection & conn ){ handler code goes here }) onmessage ([ & ]( crow :: websocket :: connection & conn , const std :: string & message , bool is_binary ){ handler code goes here }) onerror ([ & ]( crow :: websocket :: connection & conn , const std :: string & error_message ){ handler code goes here }) onclose ([ & ]( crow :: websocket :: connection & conn , const std :: string & reason ){ handler code goes here }) Note onaccept must return a boolean. In case false is returned, the connection is shut down, deleted, and no further communication is done. Warning By default, Crow allows Clients to send unmasked websocket messages, which is useful for debugging but goes against the protocol specification. Production Crow applications should enforce the protocol by adding #define CROW_ENFORCE_WS_SPEC to their source code. These event methods and their handlers can be chained. The full Route should look similar to this: CROW_ROUTE ( app , \"/ws\" ) . websocket () . onopen ([ & ]( crow :: websocket :: connection & conn ){ do_something (); }) . onclose ([ & ]( crow :: websocket :: connection & conn , const std :: string & reason ){ do_something (); }) . onmessage ([ & ]( crow :: websocket :: connection & /*conn*/ , const std :: string & data , bool is_binary ){ if ( is_binary ) do_something ( data ); else do_something_else ( data ); });","title":"Routes"},{"location":"guides/websockets/#maximum-payload-size","text":"master The maximum payload size that a connection accepts can be adjusted either globally by using app . websocket_max_payload ( < value in bytes > ) or per route by using CROW_WEBSOCKET_ROUTE ( app , \"/url\" ). max_payload ( < value in bytes > ) . In case a message was sent that exceeded the limit. The connection would be shut down and onerror would be triggered. Note By default, This limit is disabled. To disable the global setting in specific routes, you only need to call CROW_WEBSOCKET_ROUTE ( app , \"/url\" ). max_payload ( UINT64_MAX ) . For more info about websocket routes go here . For more info about websocket connections go here .","title":"Maximum payload size"}]}